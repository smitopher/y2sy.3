
#
# The name of the application.
# If not set, defaults to the name of the project (except for tests where it is not set at all).
#
#quarkus.application.name=

#
# The version of the application.
# If not set, defaults to the version of the project (except for tests where it is not set at all).
#
#quarkus.application.version=

#
# If set to true '@Inject' is automatically added to all non-static fields that are annotated with
# one of the annotations defined by {@link AutoInjectAnnotationBuildItem}.
#
#quarkus.arc.auto-inject-fields=true

#
# If set to true then 'javax.enterprise.inject.Produces' is automatically added to all methods that are
# annotated with a scope annotation, a stereotype or a qualifier, and are not annotated with 'Inject' or
# 'Produces', and no parameter is annotated with 'Disposes', 'Observes' or 'ObservesAsync'.
#
#quarkus.arc.auto-producer-methods=true

#
# The default naming strategy for {@link ConfigProperties.NamingStrategy}. The allowed values are determined
# by that enum
#
#quarkus.arc.config-properties-default-naming-strategy=kebab-case

#
# If set to true, Arc will transform the bytecode of beans containing methods that need to be proxyable
# but have been declared as final. The transformation is simply a matter of removing final.
# This ensures that a proxy/subclass can be created properly.
# If the value is set to false, then an exception is thrown at build time indicating
# that a proxy could not be created because a method was final.
#
# @deprecated This config property is ignored and will be removed at some point post Quarkus 1.4
# @see #transformUnproxyableClasses
#
#quarkus.arc.remove-final-for-proxyable-methods=true

#
# 
#  - If set to 'all' (or 'true') the container will attempt to remove all unused beans.
#  - If set to 'none' (or 'false') no beans will ever be removed even if they are unused (according to the
# criteria set out
# below)
#  - If set to 'fwk', then all unused beans will be removed, except the unused beans whose classes are declared in
# the
# application code
# 
#
# An unused bean:
# 
#  - is not a built-in bean or interceptor,
#  - is not eligible for injection to any injection point,
#  - is not excluded by any extension,
#  - does not have a name,
#  - does not declare an observer,
#  - does not declare any producer which is eligible for injection to any injection point,
#  - is not directly eligible for injection into any {@link javax.enterprise.inject.Instance} injection point
# 
#
# @see UnremovableBeanBuildItem
#
#quarkus.arc.remove-unused-beans=all

#
# The list of selected alternatives for an application.
#
# An element value can be:
# 
#  - a fully qualified class name, i.e. 'org.acme.Foo'
#  - a simple class name as defined by {@link Class#getSimpleName()}, i.e. 'Foo'
#  - a package name with suffix '.*', i.e. 'org.acme.*', matches a package
#  - a package name with suffix '.**', i.e. 'org.acme.**', matches a package that starts with the value
# 
# Each element value is used to match an alternative bean class, an alternative stereotype annotation type or a bean class
# that declares an alternative producer. If any value matches then the priority of {@link Integer#MAX_VALUE} is used for
# the relevant bean. The priority declared via {@link javax.annotation.Priority} or
# {@link io.quarkus.arc.AlternativePriority} is overriden.
#
#quarkus.arc.selected-alternatives=

#
# If set to true, the bytecode of unproxyable beans will be transformed. This ensures that a proxy/subclass
# can be created properly. If the value is set to false, then an exception is thrown at build time indicating that a
# subclass/proxy could not be created.
#
#quarkus.arc.transform-unproxyable-classes=true

#
# The arguments passed to the command line.
#
# We don't make it a list as the args are separated by a space, not a comma.
#
#quarkus.args=

#
# Whether or not the banner will be displayed
#
#quarkus.banner.enabled=true

#
# The path of the banner (path relative to root of classpath)
# which could be provided by user
#
#quarkus.banner.path=default_banner.txt

#
# Whether or not a image build will be performed.
#
#quarkus.container-image.build=false

#
# The group the container image will be part of
#
#quarkus.container-image.group=${user.name}

#
# Whether or not insecure registries are allowed
#
#quarkus.container-image.insecure=false

#
# The name of the container image. If not set defaults to the application name
#
#quarkus.container-image.name=${quarkus.application.name:unset}

#
# The password to use to authenticate with the registry where the built image will be pushed
#
#quarkus.container-image.password=

#
# Whether or not an image push will be performed.
#
#quarkus.container-image.push=false

#
# The container registry to use
#
#quarkus.container-image.registry=

#
# The tag of the container image. If not set defaults to the application version
#
#quarkus.container-image.tag=${quarkus.application.version:latest}

#
# The username to use to authenticate with the registry where the built image will be pushed
#
#quarkus.container-image.username=

#
# @deprecated use quarkus.datasource.jdbc.acquisition-timeout instead.
#
#quarkus.datasource.*.acquisition-timeout=5

#
# @deprecated use quarkus.datasource.jdbc.background-validation-interval instead.
#
#quarkus.datasource.*.background-validation-interval=2M

#
# The credentials provider name
#
#quarkus.datasource.*.credentials-provider=

#
# The credentials provider type.
#
# It is the '&#64;Named' value of the credentials provider bean. It is used to discriminate if multiple
# CredentialsProvider beans are available.
#
# For Vault it is: vault-credentials-provider. Not necessary if there is only one credentials provider available.
#
#quarkus.datasource.*.credentials-provider-type=

#
# The kind of database we will connect to (e.g. h2, postgresql...).
#
#quarkus.datasource.*.db-kind=

#
# @deprecated use quarkus.datasource.jdbc.detect-statement-leaks instead.
#
#quarkus.datasource.*.detect-statement-leaks=true

#
# @deprecated use quarkus.datasource.db-kind (and quarkus.datasource.jdbc.driver if you really need a specific JDBC
# driver).
#
#quarkus.datasource.*.driver=

#
# @deprecated use quarkus.datasource.jdbc.enable-metrics instead.
#
#quarkus.datasource.*.enable-metrics=

#
# @deprecated use quarkus.datasource.jdbc.idle-removal-interval instead.
#
#quarkus.datasource.*.idle-removal-interval=5M

#
# @deprecated use quarkus.datasource.jdbc.initial-size instead.
#
#quarkus.datasource.*.initial-size=

#
# If we create a JDBC datasource for this datasource.
#
#quarkus.datasource.*.jdbc=true

#
# The timeout before cancelling the acquisition of a new connection
#
#quarkus.datasource.*.jdbc.acquisition-timeout=5

#
# The interval at which we validate idle connections in the background.
#
# Set to '0' to disable background validation.
#
#quarkus.datasource.*.jdbc.background-validation-interval=2M

#
# When enabled Agroal will be able to produce a warning when a connection is returned
# to the pool without the application having closed all open statements.
# This is unrelated with tracking of open connections.
# Disable for peak performance, but only when there's high confidence that
# no leaks are happening.
#
#quarkus.datasource.*.jdbc.detect-statement-leaks=true

#
# The datasource driver class name
#
#quarkus.datasource.*.jdbc.driver=

#
# Enable datasource metrics collection. If unspecified, collecting metrics will be enabled by default if the
# smallrye-metrics extension is active.
#
#quarkus.datasource.*.jdbc.enable-metrics=

#
# The interval at which we try to remove idle connections.
#
#quarkus.datasource.*.jdbc.idle-removal-interval=5M

#
# The initial size of the pool. Usually you will want to set the initial size to match at least the
# minimal size, but this is not enforced so to allow for architectures which prefer a lazy initialization
# of the connections on boot, while being able to sustain a minimal pool size after boot.
#
#quarkus.datasource.*.jdbc.initial-size=

#
# The interval at which we check for connection leaks.
#
#quarkus.datasource.*.jdbc.leak-detection-interval=

#
# The max lifetime of a connection.
#
#quarkus.datasource.*.jdbc.max-lifetime=

#
# The datasource pool maximum size
#
#quarkus.datasource.*.jdbc.max-size=20

#
# The datasource pool minimum size
#
#quarkus.datasource.*.jdbc.min-size=0

#
# Query executed when first using a connection.
#
#quarkus.datasource.*.jdbc.new-connection-sql=

#
# The transaction isolation level.
#
#quarkus.datasource.*.jdbc.transaction-isolation-level=

#
# Whether we want to use regular JDBC transactions, XA, or disable all transactional capabilities.
#
# When enabling XA you will need a driver implementing {@link javax.sql.XADataSource}.
#
#quarkus.datasource.*.jdbc.transactions=enabled

#
# The datasource URL
#
#quarkus.datasource.*.jdbc.url=

#
# Query executed to validate a connection.
#
#quarkus.datasource.*.jdbc.validation-query-sql=

#
# @deprecated use quarkus.datasource.jdbc.leak-detection-interval instead.
#
#quarkus.datasource.*.leak-detection-interval=

#
# @deprecated use quarkus.datasource.jdbc.max-lifetime instead.
#
#quarkus.datasource.*.max-lifetime=

#
# @deprecated use either quarkus.datasource.jdbc.max-size or quarkus.datasource.reactive.max-size.
#
#quarkus.datasource.*.max-size=20

#
# @deprecated use quarkus.datasource.jdbc.min-size instead.
#
#quarkus.datasource.*.min-size=0

#
# @deprecated use quarkus.datasource.jdbc.new-connection-sql instead.
#
#quarkus.datasource.*.new-connection-sql=

#
# The datasource password
#
#quarkus.datasource.*.password=

#
# @deprecated use quarkus.datasource.jdbc.transaction-isolation-level instead.
#
#quarkus.datasource.*.transaction-isolation-level=

#
# @deprecated use quarkus.datasource.jdbc.transactions instead.
#
#quarkus.datasource.*.transactions=enabled

#
# @deprecated use either quarkus.datasource.jdbc.url or quarkus.datasource.reactive.url.
#
#quarkus.datasource.*.url=

#
# The datasource username
#
#quarkus.datasource.*.username=

#
# @deprecated use quarkus.datasource.jdbc.validation-query-sql instead.
#
#quarkus.datasource.*.validation-query-sql=

#
# @deprecated use quarkus.datasource.jdbc.acquisition-timeout instead.
#
#quarkus.datasource.acquisition-timeout=5

#
# @deprecated use quarkus.datasource.jdbc.background-validation-interval instead.
#
#quarkus.datasource.background-validation-interval=2M

#
# The credentials provider name
#
#quarkus.datasource.credentials-provider=cmf01

#
# The credentials provider type.
#
# It is the '&#64;Named' value of the credentials provider bean. It is used to discriminate if multiple
# CredentialsProvider beans are available.
#
# For Vault it is: vault-credentials-provider. Not necessary if there is only one credentials provider available.
#
#quarkus.datasource.credentials-provider-type=

#
# The kind of database we will connect to (e.g. h2, postgresql...).
#
quarkus.datasource.db-kind=other

#
# @deprecated use quarkus.datasource.jdbc.detect-statement-leaks instead.
#
#quarkus.datasource.detect-statement-leaks=true

#
# @deprecated use quarkus.datasource.db-kind (and quarkus.datasource.jdbc.driver if you really need a specific JDBC
# driver).
#
#quarkus.datasource.driver=

#
# @deprecated use quarkus.datasource.jdbc.enable-metrics instead.
#
#quarkus.datasource.enable-metrics=

#
# Whether or not an health check is published in case the smallrye-health extension is present.
#
# This is a global setting and is not specific to a datasource.
#
#quarkus.datasource.health.enabled=true

#
# @deprecated use quarkus.datasource.jdbc.idle-removal-interval instead.
#
#quarkus.datasource.idle-removal-interval=5M

#
# @deprecated use quarkus.datasource.jdbc.initial-size instead.
#
#quarkus.datasource.initial-size=

#
# If we create a JDBC datasource for this datasource.
#
#quarkus.datasource.jdbc=true

#
# The timeout before cancelling the acquisition of a new connection
#
#quarkus.datasource.jdbc.acquisition-timeout=5

#
# The interval at which we validate idle connections in the background.
#
# Set to '0' to disable background validation.
#
#quarkus.datasource.jdbc.background-validation-interval=2M

#
# When enabled Agroal will be able to produce a warning when a connection is returned
# to the pool without the application having closed all open statements.
# This is unrelated with tracking of open connections.
# Disable for peak performance, but only when there's high confidence that
# no leaks are happening.
#
#quarkus.datasource.jdbc.detect-statement-leaks=true

#
# The datasource driver class name
#
quarkus.datasource.jdbc.driver=com.ibm.as400.access.AS400JDBCDriver

#
# Enable datasource metrics collection. If unspecified, collecting metrics will be enabled by default if the
# smallrye-metrics extension is active.
#
#quarkus.datasource.jdbc.enable-metrics=

#
# The interval at which we try to remove idle connections.
#
#quarkus.datasource.jdbc.idle-removal-interval=5M

#
# The initial size of the pool. Usually you will want to set the initial size to match at least the
# minimal size, but this is not enforced so to allow for architectures which prefer a lazy initialization
# of the connections on boot, while being able to sustain a minimal pool size after boot.
#
#quarkus.datasource.jdbc.initial-size=

#
# The interval at which we check for connection leaks.
#
#quarkus.datasource.jdbc.leak-detection-interval=

#
# The max lifetime of a connection.
#
#quarkus.datasource.jdbc.max-lifetime=

#
# The datasource pool maximum size
#
#quarkus.datasource.jdbc.max-size=20

#
# The datasource pool minimum size
#
#quarkus.datasource.jdbc.min-size=0

#
# Query executed when first using a connection.
#
#quarkus.datasource.jdbc.new-connection-sql=

#
# The transaction isolation level.
#
#quarkus.datasource.jdbc.transaction-isolation-level=

#
# Whether we want to use regular JDBC transactions, XA, or disable all transactional capabilities.
#
# When enabling XA you will need a driver implementing {@link javax.sql.XADataSource}.
#
#quarkus.datasource.jdbc.transactions=enabled

#
# The datasource URL
#
quarkus.datasource.jdbc.url=${dburl}

#
# Query executed to validate a connection.
#
#quarkus.datasource.jdbc.validation-query-sql=

#
# @deprecated use quarkus.datasource.jdbc.leak-detection-interval instead.
#
#quarkus.datasource.leak-detection-interval=

#
# @deprecated use quarkus.datasource.jdbc.max-lifetime instead.
#
#quarkus.datasource.max-lifetime=

#
# @deprecated use either quarkus.datasource.jdbc.max-size or quarkus.datasource.reactive.max-size.
#
#quarkus.datasource.max-size=20

#
# Whether or not datasource metrics are published in case the smallrye-metrics extension is present.
#
# This is a global setting and is not specific to a datasource.
#
# NOTE: This is different from the "jdbc.enable-metrics" property that needs to be set on the JDBC datasource level to
# enable collection of metrics for that datasource.
#
#quarkus.datasource.metrics.enabled=false

#
# @deprecated use quarkus.datasource.jdbc.min-size instead.
#
#quarkus.datasource.min-size=0

#
# @deprecated use quarkus.datasource.jdbc.new-connection-sql instead.
#
#quarkus.datasource.new-connection-sql=

#
# The datasource password
#
quarkus.datasource.password=${dbpassword}

#
# @deprecated use quarkus.datasource.jdbc.transaction-isolation-level instead.
#
#quarkus.datasource.transaction-isolation-level=

#
# @deprecated use quarkus.datasource.jdbc.transactions instead.
#
#quarkus.datasource.transactions=enabled

#
# @deprecated use either quarkus.datasource.jdbc.url or quarkus.datasource.reactive.url.
#
#quarkus.datasource.url=

#
# The datasource username
#
quarkus.datasource.username=${dbuser}

#
# @deprecated use quarkus.datasource.jdbc.validation-query-sql instead.
#
#quarkus.datasource.validation-query-sql=

#
# If set to a directory, all generated classes will be written into that directory
#
#quarkus.debug.generated-classes-dir=

#
# If set to true, writes a list of all reflective classes to META-INF
#
#quarkus.debug.reflection=false

#
# Default locale that can be consumed by the extensions.
#
# The locales must be specified in the IETF BCP 47 format e.g. en-US or fr-FR.
#
# For instance, the Hibernate Validator extension makes use of it.
#
#quarkus.default-locale=${user.language:en}-${user.country:}

#
# Path to the the JVM Dockerfile.
# If not set ${project.root}/src/main/docker/Dockerfile.jvm will be used
# If set to an absolute path then the absolute path will be used, otherwise the path
# will be considered relative to the project root
#
#quarkus.docker.dockerfile-jvm-path=

#
# Path to the the JVM Dockerfile.
# If not set ${project.root}/src/main/docker/Dockerfile.native will be used
# If set to an absolute path then the absolute path will be used, otherwise the path
# will be considered relative to the project root
#
#quarkus.docker.dockerfile-native-path=

#
# Whether or not extensions published health check should be enabled.
#
#quarkus.health.extensions.enabled=true

#
# The size of the batches used when loading entities and collections.
#
# `-1` means batch loading is disabled. This is the default.
#
# @asciidoclet
#
#quarkus.hibernate-orm.batch-fetch-size=-1

#
# The maximum time before an object of the cache is considered expired.
#
#quarkus.hibernate-orm.cache.*.expiration.max-idle=

#
# The maximum number of objects kept in memory in the cache.
#
#quarkus.hibernate-orm.cache.*.memory.object-count=

#
# The charset of the database.
#
#quarkus.hibernate-orm.database.charset=

#
# The default catalog to use for the database objects.
#
#quarkus.hibernate-orm.database.default-catalog=

#
# The default schema to use for the database objects.
#
quarkus.hibernate-orm.database.default-schema=CMINSMDL2


#
# Select whether the database schema is generated or not.
#
# `drop-and-create` is awesome in development mode.
#
# Accepted values: `none`, `create`, `drop-and-create`, `drop`, `update`.
#
quarkus.hibernate-orm.database.generation=none

#
# Whether we should stop on the first error when applying the schema.
#
#quarkus.hibernate-orm.database.generation.halt-on-error=false

#
# Whether Hibernate should quote all identifiers.
#
#quarkus.hibernate-orm.database.globally-quoted-identifiers=false

#
# Class name of the Hibernate ORM dialect. The complete list of bundled dialects is available in the
# https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/dialect/package-summary.html[Hibernate ORM JavaDoc].
#
# [NOTE]
# ====
# Not all the dialects are supported in GraalVM native executables: we currently provide driver extensions for PostgreSQL,
# MariaDB, Microsoft SQL Server and H2.
# ====
#
# @asciidoclet
#
quarkus.hibernate-orm.dialect=org.hibernate.dialect.DB2400V7R3Dialect

#
# The storage engine to use when the dialect supports multiple storage engines.
#
# E.g. `MyISAM` or `InnoDB` for MySQL.
#
# @asciidoclet
#
#quarkus.hibernate-orm.dialect.storage-engine=

#
# Pluggable strategy for applying implicit naming rules when an explicit name is not given.
#
# Class name of the Hibernate ImplicitNamingStrategy implementation
#
#quarkus.hibernate-orm.implicit-naming-strategy=

#
# The number of updates (inserts, updates and deletes) that are sent by the JDBC driver at one time for execution.
#
#quarkus.hibernate-orm.jdbc.statement-batch-size=

#
# How many rows are fetched at a time by the JDBC driver.
#
#quarkus.hibernate-orm.jdbc.statement-fetch-size=

#
# The time zone pushed to the JDBC driver.
#
#quarkus.hibernate-orm.jdbc.timezone=

#
# Logs SQL bind parameter.
#
# Setting it to true is obviously not recommended in production.
#
#quarkus.hibernate-orm.log.bind-param=false

#
# Whether JDBC warnings should be collected and logged.
#
#quarkus.hibernate-orm.log.jdbc-warnings=

#
# Show SQL logs and format them nicely.
#
# Setting it to true is obviously not recommended in production.
#
#quarkus.hibernate-orm.log.sql=false

#
# Whether or not metrics are published in case the smallrye-metrics extension is present (default to false).
#
#quarkus.hibernate-orm.metrics.enabled=false

#
# Pluggable strategy contract for applying physical naming rules for database object names.
#
# Class name of the Hibernate PhysicalNamingStrategy implementation
#
#quarkus.hibernate-orm.physical-naming-strategy=

#
# Default precedence of null values in `ORDER BY` clauses.
#
# Valid values are: `none`, `first`, `last`.
#
# @asciidoclet
#
#quarkus.hibernate-orm.query.default-null-ordering=

#
# The maximum size of the query plan cache.
#
#quarkus.hibernate-orm.query.query-plan-cache-max-size=

#
# The default in Quarkus is for 2nd level caching to be enabled,
# and a good implementation is already integrated for you.
#
# Just cherry-pick which entities should be using the cache.
#
# Set this to false to disable all 2nd level caches.
#
#quarkus.hibernate-orm.second-level-caching-enabled=true

#
# Name of the file containing the SQL statements to execute when Hibernate ORM starts.
# Its default value differs depending on the Quarkus launch mode:
#
# * In dev and test modes, it defaults to `import.sql`.
# Simply add an `import.sql` file in the root of your resources directory
# and it will be picked up without having to set this property.
# Pass `no-file` to force Hibernate ORM to ignore the SQL import file.
# * In production mode, it defaults to `no-file`.
# It means Hibernate ORM won't try to execute any SQL import file by default.
# Pass an explicit value to force Hibernate ORM to execute the SQL import file.
#
# If you need different SQL statements between dev mode, test (`@QuarkusTest`) and in production, use Quarkus
# https://quarkus.io/guides/config#configuration-profiles[configuration profiles facility].
#
# [source,property]
# .application.properties
# ----
# %dev.quarkus.hibernate-orm.sql-load-script = import-dev.sql
# %test.quarkus.hibernate-orm.sql-load-script = import-test.sql
# %prod.quarkus.hibernate-orm.sql-load-script = no-file
# ----
#
# [NOTE]
# ====
# Quarkus supports `.sql` file with SQL statements or comments spread over multiple lines.
# Each SQL statement must be terminated by a semicolon.
# ====
#
# @asciidoclet
#
#quarkus.hibernate-orm.sql-load-script=

#
# Whether statistics collection is enabled. If 'metrics.enabled' is true, then the default here is
# considered true, otherwise the default is false.
#
#quarkus.hibernate-orm.statistics=

#
# Enable the fail fast mode. When fail fast is enabled the validation
# will stop on the first constraint violation detected.
#
#quarkus.hibernate-validator.fail-fast=false

#
# Define whether more than one constraint on a return value may be marked for cascading validation are allowed.
# The default value is 'false', i.e. do not allow.
#
# See Section 4.5.5 of the JSR 380 specification, specifically
#
# <pre>
# "One must not mark a method return value for cascaded validation more than once in a line of a class hierarchy.
# In other words, overriding methods on sub types (be it sub classes/interfaces or interface implementations)
# cannot mark the return value for cascaded validation if the return value has already been marked on the
# overridden method of the super type or interface."
# </pre>
#
#quarkus.hibernate-validator.method-validation.allow-multiple-cascaded-validation-on-return-values=false

#
# Define whether overriding methods that override constraints should throw a 'ConstraintDefinitionException'.
# The default value is 'false', i.e. do not allow.
#
# See Section 4.5.5 of the JSR 380 specification, specifically
#
# <pre>
# "In sub types (be it sub classes/interfaces or interface implementations), no parameter constraints may
# be declared on overridden or implemented methods, nor may parameters be marked for cascaded validation.
# This would pose a strengthening of preconditions to be fulfilled by the caller."
# </pre>
#
#quarkus.hibernate-validator.method-validation.allow-overriding-parameter-constraints=false

#
# Define whether parallel methods that define constraints should throw a 'ConstraintDefinitionException'. The
# default value is 'false', i.e. do not allow.
#
# See Section 4.5.5 of the JSR 380 specification, specifically
#
# <pre>
# "If a sub type overrides/implements a method originally defined in several parallel types of the hierarchy
# (e.g. two interfaces not extending each other, or a class and an interface not implemented by said class),
# no parameter constraints may be declared for that method at all nor parameters be marked for cascaded validation.
# This again is to avoid an unexpected strengthening of preconditions to be fulfilled by the caller."
# </pre>
#
#quarkus.hibernate-validator.method-validation.allow-parameter-constraints-on-parallel-methods=false

#
# The access log file base name, defaults to 'quarkus' which will give a log file
# name of 'quarkus.log'.
#
#quarkus.http.access-log.base-file-name=quarkus

#
# The log category to use if logging is being done via the standard log mechanism (i.e. if base-file-name is empty).
#
#quarkus.http.access-log.category=io.quarkus.http.access-log

#
# If access logging is enabled. By default this will log via the standard logging facility
#
#quarkus.http.access-log.enabled=false

#
# The log directory to use when logging access to a file
#
# If this is not set then the current working directory is used.
#
#quarkus.http.access-log.log-directory=

#
# The log file suffix
#
#quarkus.http.access-log.log-suffix=.log

#
# If logging should be done to a separate file.
#
#quarkus.http.access-log.log-to-file=false

#
# The access log pattern:
#
# If this is the string 'common' or 'combined' then this will use one of the specified named formats:
#
# common: %h %l %u %t "%r" %s %b
# combined: %h %l %u %t "%r" %s %b "%{i,Referer}" "%{i,User-Agent}"
#
# Otherwise consult the Quarkus documentation for the full list of variables that can be used.
#
#quarkus.http.access-log.pattern=common

#
# If the log should be rotated daily
#
#quarkus.http.access-log.rotate=true

#
# If this is true and proxy address forwarding is enabled then the standard 'Forwarded' header will be used,
# rather than the more common but not standard 'X-Forwarded-For'.
#
#quarkus.http.allow-forwarded=false

#
# If basic auth should be enabled. If both basic and form auth is enabled then basic auth will be enabled in silent mode.
#
# If no authentication mechanisms are configured basic auth is the default.
#
#quarkus.http.auth.basic=false

#
# The cookie that is used to store the persistent session
#
#quarkus.http.auth.form.cookie-name=quarkus-credential

#
# If form authentication is enabled
#
#quarkus.http.auth.form.enabled=false

#
# The error page
#
#quarkus.http.auth.form.error-page=/error.html

#
# The landing page to redirect to if there is no saved page to redirect back to
#
#quarkus.http.auth.form.landing-page=/index.html

#
# The login page
#
#quarkus.http.auth.form.login-page=/login.html

#
# How old a cookie can get before it will be replaced with a new cookie with an updated timeout, also
# referred to as "renewal-timeout".
#
# Note that smaller values will result in slightly more server load (as new encrypted cookies will be
# generated more often), however larger values affect the inactivity timeout as the timeout is set
# when a cookie is generated.
#
# For example if this is set to 10 minutes, and the inactivity timeout is 30m, if a users last request
# is when the cookie is 9m old then the actual timeout will happen 21m after the last request, as the timeout
# is only refreshed when a new cookie is generated.
#
# In other words no timeout is tracked on the server side; the timestamp is encoded and encrypted in the cookie itself
# and it is decrypted and parsed with each request.
#
#quarkus.http.auth.form.new-cookie-interval=PT1M

#
# Option to disable redirect to landingPage if there is no saved page to redirect back to. Form Auth POST is followed
# by redirect to landingPage by default.
#
#quarkus.http.auth.form.redirect-after-login=true

#
# The inactivity (idle) timeout
#
# When inactivity timeout is reached, cookie is not renewed and a new login is enforced.
#
#quarkus.http.auth.form.timeout=PT30M

#
# The methods that this permission set applies to. If this is not set then they apply to all methods.
#
# Note that if a request matches any path from any permission set, but does not match the constraint
# due to the method not being listed then the request will be denied.
#
# Method specific permissions take precedence over matches that do not have any methods set.
#
# This means that for example if Quarkus is configured to allow GET and POST requests to /admin to
# and no other permissions are configured PUT requests to /admin will be denied.
#
#quarkus.http.auth.permission.*.methods=

#
# The paths that this permission check applies to. If the path ends in /* then this is treated
# as a path prefix, otherwise it is treated as an exact match.
#
# Matches are done on a length basis, so the most specific path match takes precedence.
#
# If multiple permission sets match the same path then explicit methods matches take precedence
# over over matches without methods set, otherwise the most restrictive permissions are applied.
#
#quarkus.http.auth.permission.*.paths=

#
# The HTTP policy that this permission set is linked to.
#
# There are 3 built in policies: permit, deny and authenticated. Role based
# policies can be defined, and extensions can add their own policies.
#
#quarkus.http.auth.permission.*.policy=

#
# The roles that are allowed to access resources protected by this policy
#
#quarkus.http.auth.policy.*.roles-allowed=

#
# If this is true and credentials are present then a user will always be authenticated
# before the request progresses.
#
# If this is false then an attempt will only be made to authenticate the user if a permission
# check is performed or the current user is required for some other reason.
#
#quarkus.http.auth.proactive=true

#
# The authentication realm
#
#quarkus.http.auth.realm=Quarkus

#
# The encryption key that is used to store persistent logins (e.g. for form auth). Logins are stored in a persistent
# cookie that is encrypted with AES-256 using a key derived from a SHA-256 hash of the key that is provided here.
#
# If no key is provided then an in-memory one will be generated, this will change on every restart though so it
# is not suitable for production environments. This must be more than 16 characters long for security reasons
#
#quarkus.http.auth.session.encryption-key=

#
# Whether the uploaded files should be removed after serving the request.
#
# If 'true' the uploaded files stored in 'quarkus.http.body-handler.uploads-directory' will be removed
# after handling the request. Otherwise the files will be left there forever.
#
#quarkus.http.body.delete-uploaded-files-on-end=false

#
# Whether the files sent using 'multipart/form-data' will be stored locally.
#
# If 'true', they will be stored in 'quarkus.http.body-handler.uploads-directory' and will be made
# available via 'io.vertx.ext.web.RoutingContext.fileUploads()'. Otherwise, the the files sent using
# 'multipart/form-data' will not be stored locally, and 'io.vertx.ext.web.RoutingContext.fileUploads()'
# will always return an empty collection. Note that even with this option being set to 'false', the
# 'multipart/form-data' requests will be accepted.
#
#quarkus.http.body.handle-file-uploads=true

#
# Whether the form attributes should be added to the request parameters.
#
# If 'true', the form attributes will be added to the request parameters; otherwise the form parameters will
# not be added to the request parameters
#
#quarkus.http.body.merge-form-attributes=true

#
# Whether the body buffer should pre-allocated based on the 'Content-Length' header value.
#
# If 'true' the body buffer is pre-allocated according to the size read from the 'Content-Length'
# header. Otherwise the body buffer is pre-allocated to 1KB, and is resized dynamically
#
#quarkus.http.body.preallocate-body-buffer=false

#
# The directory where the files sent using 'multipart/form-data' should be stored.
#
# Either an absolute path or a path relative to the current directory of the application process.
#
#quarkus.http.body.uploads-directory=file-uploads

#
# Enable the CORS filter.
#
#quarkus.http.cors=false

#
# The `Access-Control-Max-Age` response header value indicating
# how long the results of a pre-flight request can be cached.
#
#quarkus.http.cors.access-control-max-age=

#
# HTTP headers exposed in CORS
#
# Comma separated list of valid headers. ex: X-Custom,Content-Disposition
#
# default: empty
#
#quarkus.http.cors.exposed-headers=

#
# HTTP headers allowed for CORS
#
# Comma separated list of valid headers. ex: X-Custom,Content-Disposition
# The filter allows any header if this is not set.
#
# default: returns any requested header as valid
#
#quarkus.http.cors.headers=

#
# HTTP methods allowed for CORS
#
# Comma separated list of valid methods. ex: GET,PUT,POST
# The filter allows any method if this is not set.
#
# default: returns any requested method as valid
#
#quarkus.http.cors.methods=

#
# Origins allowed for CORS
#
# Comma separated list of valid URLs. ex: http://www.quarkus.io,http://localhost:3000
# The filter allows any origin if this is not set.
#
# default: returns any requested origin as valid
#
#quarkus.http.cors.origins=

#
# Path to a unix domain socket
#
#quarkus.http.domain-socket=/var/run/io.quarkus.app.socket

#
# Enable listening to host:port
#
#quarkus.http.domain-socket-enabled=false

#
# The HTTP host
#
#quarkus.http.host=0.0.0.0

#
# Enable listening to host:port
#
#quarkus.http.host-enabled=true

#
# If this is true (the default) then HTTP/2 will be enabled.
#
# Note that for browsers to be able to use it HTTPS must be enabled,
# and you must be running on JDK11 or above, as JDK8 does not support
# ALPN.
#
#quarkus.http.http2=true

#
# Http connection idle timeout
#
#quarkus.http.idle-timeout=30M

#
# If insecure (i.e. http rather than https) requests are allowed. If this is 'enabled'
# then http works as normal. 'redirect' will still open the http port, but
# all requests will be redirected to the HTTPS port. 'disabled' will prevent the HTTP
# port from opening at all.
#
#quarkus.http.insecure-requests=enabled

#
# The number if IO threads used to perform IO. This will be automatically set to a reasonable value based on
# the number of CPU cores if it is not provided. If this is set to a higher value than the number of Vert.x event
# loops then it will be capped at the number of event loops.
#
# In general this should be controlled by setting quarkus.vertx.event-loops-pool-size, this setting should only
# be used if you want to limit the number of HTTP io threads to a smaller number than the total number of IO threads.
#
#quarkus.http.io-threads=

#
# The maximum size of a request body.
# Default: no limit.
#
#quarkus.http.limits.max-body-size=

#
# The max HTTP chunk size
#
#quarkus.http.limits.max-chunk-size=

#
# The maximum length of all headers.
#
#quarkus.http.limits.max-header-size=20K

#
# The HTTP port
#
#quarkus.http.port=8080

#
# If this is true then the address, scheme etc will be set from headers forwarded by the proxy server, such as
# 'X-Forwarded-For'. This should only be set if you are behind a proxy that sets these headers.
#
#quarkus.http.proxy-address-forwarding=false

#
# Http connection read timeout for blocking IO. This is the maximum amount of time
# a thread will wait for data, before an IOException will be thrown and the connection
# closed.
#
#quarkus.http.read-timeout=60s

#
# If this is true then the request start time will be recorded to enable logging of total request time.
#
# This has a small performance penalty, so is disabled by default.
#
#quarkus.http.record-request-start-time=false

#
# The HTTP root path. All web content will be served relative to this root path.
#
#quarkus.http.root-path=/

#
# Enable socket reuse port (linux/macOs native transport only)
#
#quarkus.http.so-reuse-port=false

#
# The HTTPS port
#
#quarkus.http.ssl-port=8443

#
# The file path to a server certificate or certificate chain in PEM format.
#
#quarkus.http.ssl.certificate.file=

#
# The file path to the corresponding certificate private key file in PEM format.
#
#quarkus.http.ssl.certificate.key-file=

#
# An optional key store which holds the certificate information instead of specifying separate files.
#
#quarkus.http.ssl.certificate.key-store-file=

#
# An optional parameter to specify type of the key store file. If not given, the type is automatically detected
# based on the file name.
#
#quarkus.http.ssl.certificate.key-store-file-type=

#
# A parameter to specify the password of the key store file. If not given, the default ("password") is used.
#
#quarkus.http.ssl.certificate.key-store-password=password

#
# An optional trust store which holds the certificate information of the certificates to trust
#
#quarkus.http.ssl.certificate.trust-store-file=

#
# An optional parameter to specify type of the trust store file. If not given, the type is automatically detected
# based on the file name.
#
#quarkus.http.ssl.certificate.trust-store-file-type=

#
# A parameter to specify the password of the trust store file.
#
#quarkus.http.ssl.certificate.trust-store-password=

#
# The cipher suites to use. If none is given, a reasonable default is selected.
#
#quarkus.http.ssl.cipher-suites=

#
# Configures the engine to require/request client authentication.
# NONE, REQUEST, REQUIRED
#
#quarkus.http.ssl.client-auth=NONE

#
# The list of protocols to explicitly enable.
#
#quarkus.http.ssl.protocols=TLSv1.3,TLSv1.2

#
# Enable tcp cork (linux native transport only)
#
#quarkus.http.tcp-cork=false

#
# Enable tcp fast open (linux native transport only)
#
#quarkus.http.tcp-fast-open=false

#
# Enable tcp quick ack (linux native transport only)
#
#quarkus.http.tcp-quick-ack=false

#
# The HTTP port used to run tests
#
#quarkus.http.test-port=8081

#
# The HTTPS port used to run tests
#
#quarkus.http.test-ssl-port=8444

#
# If this is true then only a virtual channel will be set up for vertx web.
# We have this switch for testing purposes.
#
#quarkus.http.virtual=false

#
# The maven artifactId of the artifact to index
#
#quarkus.index-dependency.*.artifact-id=

#
# The maven classifier of the artifact to index
#
#quarkus.index-dependency.*.classifier=

#
# The maven groupId of the artifact to index
#
#quarkus.index-dependency.*.group-id=

#
# The hostname and port for communicating with agent via UDP
#
#quarkus.jaeger.agent-host-port=

#
# Authentication Token to send as "Bearer" to the endpoint
#
#quarkus.jaeger.auth-token=

#
# Defines if the Jaeger extension is enabled.
#
#quarkus.jaeger.enabled=true

#
# The traces endpoint, in case the client should connect directly to the Collector,
# like http://jaeger-collector:14268/api/traces
#
#quarkus.jaeger.endpoint=

#
# Whether the trace context should be logged.
#
#quarkus.jaeger.log-trace-context=true

#
# Password to send as part of "Basic" authentication to the endpoint
#
#quarkus.jaeger.password=

#
# Comma separated list of formats to use for propagating the trace context. Defaults to the
# standard Jaeger format. Valid values are jaeger and b3
#
#quarkus.jaeger.propagation=

#
# The reporter's flush interval
#
#quarkus.jaeger.reporter-flush-interval=

#
# Whether the reporter should also log the spans
#
#quarkus.jaeger.reporter-log-spans=

#
# The reporter's maximum queue size
#
#quarkus.jaeger.reporter-max-queue-size=

#
# The host name and port when using the remote controlled sampler
#
#quarkus.jaeger.sampler-manager-host-port=

#
# The sampler parameter (number)
#
#quarkus.jaeger.sampler-param=

#
# The sampler type (const, probabilistic, ratelimiting or remote)
#
#quarkus.jaeger.sampler-type=

#
# The sender factory class name
#
#quarkus.jaeger.sender-factory=

#
# The service name
#
#quarkus.jaeger.service-name=

#
# A comma separated list of name = value tracer level tags, which get added to all reported
# spans. The value can also refer to an environment variable using the format ${envVarName:default},
# where the :default is optional, and identifies a value to be used if the environment variable
# cannot be found
#
#quarkus.jaeger.tags=

#
# Username to send as part of "Basic" authentication to the endpoint
#
#quarkus.jaeger.user=

#
# @deprecated JNI is always enabled starting from GraalVM 19.3.1.
#
#quarkus.jni.enable=true

#
# Paths of library to load.
#
#quarkus.jni.library-paths=

#
# Adapters will make separate HTTP invocations to the Keycloak server to turn an access code into an access token.
# This config option defines how many connections to the Keycloak server should be pooled
#
#quarkus.keycloak.connection-pool-size=20

#

#
#quarkus.keycloak.policy-enforcer.claim-information-point.*.*=

#

#
#quarkus.keycloak.policy-enforcer.claim-information-point.*.*.*=

#
# Enables policy enforcement.
#
#quarkus.keycloak.policy-enforcer.enable=false

#
# Specifies how policies are enforced.
#
#quarkus.keycloak.policy-enforcer.enforcement-mode=ENFORCING

#
# Specifies how scopes should be mapped to HTTP methods. If set to true, the policy enforcer will use the HTTP method
# from
# the current request to check whether or not access should be granted
#
#quarkus.keycloak.policy-enforcer.http-method-as-scope=false

#
# Specifies how the adapter should fetch the server for resources associated with paths in your application. If true,
# the
# policy
# enforcer is going to fetch resources on-demand accordingly with the path being requested
#
#quarkus.keycloak.policy-enforcer.lazy-load-paths=true

#
# Defines the time in milliseconds when the entry should be expired
#
#quarkus.keycloak.policy-enforcer.path-cache.lifespan=30000

#
# Defines the limit of entries that should be kept in the cache
#
#quarkus.keycloak.policy-enforcer.path-cache.max-entries=1000

#

#
#quarkus.keycloak.policy-enforcer.paths.*.claim-information-point.*.*=

#

#
#quarkus.keycloak.policy-enforcer.paths.*.claim-information-point.*.*.*=

#
# Specifies how policies are enforced
#
#quarkus.keycloak.policy-enforcer.paths.*.enforcement-mode=ENFORCING

#
# The name of the HTTP method
#
#quarkus.keycloak.policy-enforcer.paths.*.methods.*.method=

#
# An array of strings with the scopes associated with the method
#
#quarkus.keycloak.policy-enforcer.paths.*.methods.*.scopes=

#
# A string referencing the enforcement mode for the scopes associated with a method
#
#quarkus.keycloak.policy-enforcer.paths.*.methods.*.scopes-enforcement-mode=ALL

#
# The name of a resource on the server that is to be associated with a given path
#
#quarkus.keycloak.policy-enforcer.paths.*.name=

#
# A URI relative to the applicationÃ¢Â?Â?s context path that should be protected by the policy enforcer
#
#quarkus.keycloak.policy-enforcer.paths.*.path=

#
# Whether or not to add the build timestamp to the Kubernetes annotations
# This is a very useful way to have manifests of successive builds of the same
# application differ - thus ensuring that Kubernetes will apply the updated resources
#
#quarkus.knative.add-build-timestamp=true

#
# Custom annotations to add to all resources
#
#quarkus.knative.annotations.*=

#
# The arguments
#
# @return The arguments
#
#quarkus.knative.arguments=

#
# Filesystem type.
#
#quarkus.knative.aws-elastic-block-store-volumes.*.fs-type=ext4

#
# The partition.
#
#quarkus.knative.aws-elastic-block-store-volumes.*.partition=

#
# Wether the volumeName is read only or not.
#
#quarkus.knative.aws-elastic-block-store-volumes.*.read-only=false

#
# The name of the disk to mount.
#
#quarkus.knative.aws-elastic-block-store-volumes.*.volume-id=

#
# Disk caching mode.
#
#quarkus.knative.azure-disk-volumes.*.caching-mode=ReadWrite

#
# The name of the disk to mount.
#
#quarkus.knative.azure-disk-volumes.*.disk-name=

#
# The URI of the vhd blob object OR the resourceID of an Azure managed data disk if Kind is Managed
#
#quarkus.knative.azure-disk-volumes.*.disk-uri=

#
# File system type.
#
#quarkus.knative.azure-disk-volumes.*.fs-type=ext4

#
# Kind of disk.
#
#quarkus.knative.azure-disk-volumes.*.kind=Managed

#
# Wether the volumeName is read only or not.
#
#quarkus.knative.azure-disk-volumes.*.read-only=false

#
# Wether the volumeName is read only or not.
#
#quarkus.knative.azure-file-volumes.*.read-only=false

#
# The secret name.
#
#quarkus.knative.azure-file-volumes.*.secret-name=

#
# The share name.
#
#quarkus.knative.azure-file-volumes.*.share-name=

#
# The commands
#
#quarkus.knative.command=

#
# The name of the ConfigMap to mount.
#
#quarkus.knative.config-map-volumes.*.config-map-name=

#
# Default mode.
# When specifying an octal number, leading zero must be present.
#
# @return The default mode.
#
#quarkus.knative.config-map-volumes.*.default-mode=0600

#
# Optional
#
#quarkus.knative.config-map-volumes.*.optional=false

#
# The arguments
#
# @return The arguments.
#
#quarkus.knative.containers.*.arguments=

#
# The commands
#
#quarkus.knative.containers.*.command=

#
# The environment variable config map.
#
#quarkus.knative.containers.*.env-vars.*.configmap=

#
# The environment variable field.
#
#quarkus.knative.containers.*.env-vars.*.field=

#
# The environment variable name.
#
#quarkus.knative.containers.*.env-vars.*.name=

#
# The environment variable secret.
#
#quarkus.knative.containers.*.env-vars.*.secret=

#
# The environment variable value.
#
#quarkus.knative.containers.*.env-vars.*.value=

#
# The host under which the application is going to be exposed.
#
#quarkus.knative.containers.*.host=

#
# The container image.
#
#quarkus.knative.containers.*.image=

#
# Image pull policy.
#
#quarkus.knative.containers.*.image-pull-policy=Always

#
# The image pull secret
#
#quarkus.knative.containers.*.image-pull-secrets=

#
# The command to use for the probe.
#
#quarkus.knative.containers.*.liveness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.knative.containers.*.liveness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.knative.containers.*.liveness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.knative.containers.*.liveness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.knative.containers.*.liveness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.knative.containers.*.liveness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.knative.containers.*.liveness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.knative.containers.*.liveness-probe.timeout=10s

#
# The name of the volumeName to mount.
#
# @return The name.
#
#quarkus.knative.containers.*.mounts.*.name=

#
# The path to mount.
#
# @return The path.
#
#quarkus.knative.containers.*.mounts.*.path=

#
# ReadOnly
#
# @return True if mount is readonly, False otherwise.
#
#quarkus.knative.containers.*.mounts.*.read-only=false

#
# Path within the volumeName from which the container's volumeName should be
# mounted.
#
# @return The subPath.
#
#quarkus.knative.containers.*.mounts.*.sub-path=

#
# The port number. Refers to the container port.
#
#quarkus.knative.containers.*.ports.*.container-port=

#
# The host port.
#
#quarkus.knative.containers.*.ports.*.host-port=

#
# The application path (refers to web application path).
#
# @return The path, defaults to /.
#
#quarkus.knative.containers.*.ports.*.path=/

#
# The protocol.
#
#quarkus.knative.containers.*.ports.*.protocol=TCP

#
# The command to use for the probe.
#
#quarkus.knative.containers.*.readiness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.knative.containers.*.readiness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.knative.containers.*.readiness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.knative.containers.*.readiness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.knative.containers.*.readiness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.knative.containers.*.readiness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.knative.containers.*.readiness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.knative.containers.*.readiness-probe.timeout=10s

#
# The service account.
#
#quarkus.knative.containers.*.service-account=

#
# Working directory.
#
#quarkus.knative.containers.*.working-dir=

#
# The environment variable config map.
#
#quarkus.knative.env-vars.*.configmap=

#
# The environment variable field.
#
#quarkus.knative.env-vars.*.field=

#
# The environment variable name.
#
#quarkus.knative.env-vars.*.name=

#
# The environment variable secret.
#
#quarkus.knative.env-vars.*.secret=

#
# The environment variable value.
#
#quarkus.knative.env-vars.*.value=

#
# The directory of the repository to mount.
#
#quarkus.knative.git-repo-volumes.*.directory=

#
# Git repoistory URL.
#
#quarkus.knative.git-repo-volumes.*.repository=

#
# The commit hash to use.
#
#quarkus.knative.git-repo-volumes.*.revision=

#
# The host under which the application is going to be exposed
#
#quarkus.knative.host=

#
# Image pull policy
#
#quarkus.knative.image-pull-policy=Always

#
# The image pull secret
#
#quarkus.knative.image-pull-secrets=

#
# The arguments
#
# @return The arguments.
#
#quarkus.knative.init-containers.*.arguments=

#
# The commands
#
#quarkus.knative.init-containers.*.command=

#
# The environment variable config map.
#
#quarkus.knative.init-containers.*.env-vars.*.configmap=

#
# The environment variable field.
#
#quarkus.knative.init-containers.*.env-vars.*.field=

#
# The environment variable name.
#
#quarkus.knative.init-containers.*.env-vars.*.name=

#
# The environment variable secret.
#
#quarkus.knative.init-containers.*.env-vars.*.secret=

#
# The environment variable value.
#
#quarkus.knative.init-containers.*.env-vars.*.value=

#
# The host under which the application is going to be exposed.
#
#quarkus.knative.init-containers.*.host=

#
# The container image.
#
#quarkus.knative.init-containers.*.image=

#
# Image pull policy.
#
#quarkus.knative.init-containers.*.image-pull-policy=Always

#
# The image pull secret
#
#quarkus.knative.init-containers.*.image-pull-secrets=

#
# The command to use for the probe.
#
#quarkus.knative.init-containers.*.liveness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.knative.init-containers.*.liveness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.knative.init-containers.*.liveness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.knative.init-containers.*.liveness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.knative.init-containers.*.liveness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.knative.init-containers.*.liveness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.knative.init-containers.*.liveness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.knative.init-containers.*.liveness-probe.timeout=10s

#
# The name of the volumeName to mount.
#
# @return The name.
#
#quarkus.knative.init-containers.*.mounts.*.name=

#
# The path to mount.
#
# @return The path.
#
#quarkus.knative.init-containers.*.mounts.*.path=

#
# ReadOnly
#
# @return True if mount is readonly, False otherwise.
#
#quarkus.knative.init-containers.*.mounts.*.read-only=false

#
# Path within the volumeName from which the container's volumeName should be
# mounted.
#
# @return The subPath.
#
#quarkus.knative.init-containers.*.mounts.*.sub-path=

#
# The port number. Refers to the container port.
#
#quarkus.knative.init-containers.*.ports.*.container-port=

#
# The host port.
#
#quarkus.knative.init-containers.*.ports.*.host-port=

#
# The application path (refers to web application path).
#
# @return The path, defaults to /.
#
#quarkus.knative.init-containers.*.ports.*.path=/

#
# The protocol.
#
#quarkus.knative.init-containers.*.ports.*.protocol=TCP

#
# The command to use for the probe.
#
#quarkus.knative.init-containers.*.readiness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.knative.init-containers.*.readiness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.knative.init-containers.*.readiness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.knative.init-containers.*.readiness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.knative.init-containers.*.readiness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.knative.init-containers.*.readiness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.knative.init-containers.*.readiness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.knative.init-containers.*.readiness-probe.timeout=10s

#
# The service account.
#
#quarkus.knative.init-containers.*.service-account=

#
# Working directory.
#
#quarkus.knative.init-containers.*.working-dir=

#
# Custom labels to add to all resources
#
#quarkus.knative.labels.*=

#
# The command to use for the probe.
#
#quarkus.knative.liveness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.knative.liveness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.knative.liveness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.knative.liveness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.knative.liveness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.knative.liveness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.knative.liveness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.knative.liveness-probe.timeout=10s

#
# The name of the volumeName to mount.
#
# @return The name.
#
#quarkus.knative.mounts.*.name=

#
# The path to mount.
#
# @return The path.
#
#quarkus.knative.mounts.*.path=

#
# ReadOnly
#
# @return True if mount is readonly, False otherwise.
#
#quarkus.knative.mounts.*.read-only=false

#
# Path within the volumeName from which the container's volumeName should be
# mounted.
#
# @return The subPath.
#
#quarkus.knative.mounts.*.sub-path=

#
# The name of the application. This value will be used for naming Kubernetes
# resources like: - Deployment - Service and so on ...
#
#quarkus.knative.name=${quarkus.container-image.name}

#
# The name of the group this component belongs too
#
#quarkus.knative.part-of=

#
# The port number. Refers to the container port.
#
#quarkus.knative.ports.*.container-port=

#
# The host port.
#
#quarkus.knative.ports.*.host-port=

#
# The application path (refers to web application path).
#
# @return The path, defaults to /.
#
#quarkus.knative.ports.*.path=/

#
# The protocol.
#
#quarkus.knative.ports.*.protocol=TCP

#
# The name of the claim to mount.
#
#quarkus.knative.pvc-volumes.*.claim-name=

#
# Default mode.
# When specifying an octal number, leading zero must be present.
#
# @return The default mode.
#
#quarkus.knative.pvc-volumes.*.default-mode=0600

#
# Optional
#
#quarkus.knative.pvc-volumes.*.optional=false

#
# The command to use for the probe.
#
#quarkus.knative.readiness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.knative.readiness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.knative.readiness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.knative.readiness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.knative.readiness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.knative.readiness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.knative.readiness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.knative.readiness-probe.timeout=10s

#
# Default mode.
# When specifying an octal number, leading zero must be present.
#
# @return The default mode.
#
#quarkus.knative.secret-volumes.*.default-mode=0600

#
# Optional
#
#quarkus.knative.secret-volumes.*.optional=false

#
# The name of the secret to mount.
#
#quarkus.knative.secret-volumes.*.secret-name=

#
# The service account
#
#quarkus.knative.service-account=

#
# The type of service that will be generated for the application
#
#quarkus.knative.service-type=ClusterIP

#
# The version of the application.
#
#quarkus.knative.version=${quarkus.container-image.tag}

#
# Working directory
#
#quarkus.knative.working-dir=

#
# CA certificate data
#
#quarkus.kubernetes-client.ca-cert-data=

#
# CA certificate file
#
#quarkus.kubernetes-client.ca-cert-file=

#
# Client certificate data
#
#quarkus.kubernetes-client.client-cert-data=

#
# Client certificate file
#
#quarkus.kubernetes-client.client-cert-file=

#
# Client key algorithm
#
#quarkus.kubernetes-client.client-key-algo=

#
# Client key data
#
#quarkus.kubernetes-client.client-key-data=

#
# Client key file
#
#quarkus.kubernetes-client.client-key-file=

#
# Client key passphrase
#
#quarkus.kubernetes-client.client-key-passphrase=

#
# Maximum amount of time to wait for a connection with the API server to be established
#
#quarkus.kubernetes-client.connection-timeout=PT10S

#
# HTTP proxy used to access the Kubernetes API server
#
#quarkus.kubernetes-client.http-proxy=

#
# HTTPS proxy used to access the Kubernetes API server
#
#quarkus.kubernetes-client.https-proxy=

#
# URL of the Kubernetes API server
#
#quarkus.kubernetes-client.master-url=

#
# Default namespace to use
#
#quarkus.kubernetes-client.namespace=

#
# IP addresses or hosts to exclude from proxying
#
#quarkus.kubernetes-client.no-proxy=

#
# Kubernetes auth password
#
#quarkus.kubernetes-client.password=

#
# Proxy password
#
#quarkus.kubernetes-client.proxy-password=

#
# Proxy username
#
#quarkus.kubernetes-client.proxy-username=

#
# Maximum amount of time to wait for a request to the API server to be completed
#
#quarkus.kubernetes-client.request-timeout=PT10S

#
# Maximum amount of time in milliseconds to wait for a rollout to be completed
#
#quarkus.kubernetes-client.rolling-timeout=PT15M

#
# Whether or not the client should trust a self signed certificate if so presented by the API server
#
#quarkus.kubernetes-client.trust-certs=false

#
# Kubernetes auth username
#
#quarkus.kubernetes-client.username=

#
# Watch reconnect interval
#
#quarkus.kubernetes-client.watch-reconnect-interval=PT1S

#
# Maximum reconnect attempts in case of watch failure
# By default there is no limit to the number of reconnect attempts
#
#quarkus.kubernetes-client.watch-reconnect-limit=-1

#
# Whether or not to add the build timestamp to the Kubernetes annotations
# This is a very useful way to have manifests of successive builds of the same
# application differ - thus ensuring that Kubernetes will apply the updated resources
#
#quarkus.kubernetes.add-build-timestamp=true

#
# Custom annotations to add to all resources
#
#quarkus.kubernetes.annotations.*=

#
# The arguments
#
# @return The arguments
#
#quarkus.kubernetes.arguments=

#
# Filesystem type.
#
#quarkus.kubernetes.aws-elastic-block-store-volumes.*.fs-type=ext4

#
# The partition.
#
#quarkus.kubernetes.aws-elastic-block-store-volumes.*.partition=

#
# Wether the volumeName is read only or not.
#
#quarkus.kubernetes.aws-elastic-block-store-volumes.*.read-only=false

#
# The name of the disk to mount.
#
#quarkus.kubernetes.aws-elastic-block-store-volumes.*.volume-id=

#
# Disk caching mode.
#
#quarkus.kubernetes.azure-disk-volumes.*.caching-mode=ReadWrite

#
# The name of the disk to mount.
#
#quarkus.kubernetes.azure-disk-volumes.*.disk-name=

#
# The URI of the vhd blob object OR the resourceID of an Azure managed data disk if Kind is Managed
#
#quarkus.kubernetes.azure-disk-volumes.*.disk-uri=

#
# File system type.
#
#quarkus.kubernetes.azure-disk-volumes.*.fs-type=ext4

#
# Kind of disk.
#
#quarkus.kubernetes.azure-disk-volumes.*.kind=Managed

#
# Wether the volumeName is read only or not.
#
#quarkus.kubernetes.azure-disk-volumes.*.read-only=false

#
# Wether the volumeName is read only or not.
#
#quarkus.kubernetes.azure-file-volumes.*.read-only=false

#
# The secret name.
#
#quarkus.kubernetes.azure-file-volumes.*.secret-name=

#
# The share name.
#
#quarkus.kubernetes.azure-file-volumes.*.share-name=

#
# The commands
#
#quarkus.kubernetes.command=

#
# The name of the ConfigMap to mount.
#
#quarkus.kubernetes.config-map-volumes.*.config-map-name=

#
# Default mode.
# When specifying an octal number, leading zero must be present.
#
# @return The default mode.
#
#quarkus.kubernetes.config-map-volumes.*.default-mode=0600

#
# Optional
#
#quarkus.kubernetes.config-map-volumes.*.optional=false

#
# The arguments
#
# @return The arguments.
#
#quarkus.kubernetes.containers.*.arguments=

#
# The commands
#
#quarkus.kubernetes.containers.*.command=

#
# The environment variable config map.
#
#quarkus.kubernetes.containers.*.env-vars.*.configmap=

#
# The environment variable field.
#
#quarkus.kubernetes.containers.*.env-vars.*.field=

#
# The environment variable name.
#
#quarkus.kubernetes.containers.*.env-vars.*.name=

#
# The environment variable secret.
#
#quarkus.kubernetes.containers.*.env-vars.*.secret=

#
# The environment variable value.
#
#quarkus.kubernetes.containers.*.env-vars.*.value=

#
# The host under which the application is going to be exposed.
#
#quarkus.kubernetes.containers.*.host=

#
# The container image.
#
#quarkus.kubernetes.containers.*.image=

#
# Image pull policy.
#
#quarkus.kubernetes.containers.*.image-pull-policy=Always

#
# The image pull secret
#
#quarkus.kubernetes.containers.*.image-pull-secrets=

#
# The command to use for the probe.
#
#quarkus.kubernetes.containers.*.liveness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.kubernetes.containers.*.liveness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.kubernetes.containers.*.liveness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.kubernetes.containers.*.liveness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.kubernetes.containers.*.liveness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.kubernetes.containers.*.liveness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.kubernetes.containers.*.liveness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.kubernetes.containers.*.liveness-probe.timeout=10s

#
# The name of the volumeName to mount.
#
# @return The name.
#
#quarkus.kubernetes.containers.*.mounts.*.name=

#
# The path to mount.
#
# @return The path.
#
#quarkus.kubernetes.containers.*.mounts.*.path=

#
# ReadOnly
#
# @return True if mount is readonly, False otherwise.
#
#quarkus.kubernetes.containers.*.mounts.*.read-only=false

#
# Path within the volumeName from which the container's volumeName should be
# mounted.
#
# @return The subPath.
#
#quarkus.kubernetes.containers.*.mounts.*.sub-path=

#
# The port number. Refers to the container port.
#
#quarkus.kubernetes.containers.*.ports.*.container-port=

#
# The host port.
#
#quarkus.kubernetes.containers.*.ports.*.host-port=

#
# The application path (refers to web application path).
#
# @return The path, defaults to /.
#
#quarkus.kubernetes.containers.*.ports.*.path=/

#
# The protocol.
#
#quarkus.kubernetes.containers.*.ports.*.protocol=TCP

#
# The command to use for the probe.
#
#quarkus.kubernetes.containers.*.readiness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.kubernetes.containers.*.readiness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.kubernetes.containers.*.readiness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.kubernetes.containers.*.readiness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.kubernetes.containers.*.readiness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.kubernetes.containers.*.readiness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.kubernetes.containers.*.readiness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.kubernetes.containers.*.readiness-probe.timeout=10s

#
# The service account.
#
#quarkus.kubernetes.containers.*.service-account=

#
# Working directory.
#
#quarkus.kubernetes.containers.*.working-dir=

#
# The target deployment platform.
# Defaults to kubernetes. Can be kubernetes, openshift, knative etc, or any combination of the above as comma separated
# list.
#
#quarkus.kubernetes.deployment-target=kubernetes

#
# The environment variable config map.
#
#quarkus.kubernetes.env-vars.*.configmap=

#
# The environment variable field.
#
#quarkus.kubernetes.env-vars.*.field=

#
# The environment variable name.
#
#quarkus.kubernetes.env-vars.*.name=

#
# The environment variable secret.
#
#quarkus.kubernetes.env-vars.*.secret=

#
# The environment variable value.
#
#quarkus.kubernetes.env-vars.*.value=

#
# If true, a Kubernetes Ingress will be created
#
#quarkus.kubernetes.expose=false

#
# The directory of the repository to mount.
#
#quarkus.kubernetes.git-repo-volumes.*.directory=

#
# Git repoistory URL.
#
#quarkus.kubernetes.git-repo-volumes.*.repository=

#
# The commit hash to use.
#
#quarkus.kubernetes.git-repo-volumes.*.revision=

#
# The host under which the application is going to be exposed
#
#quarkus.kubernetes.host=

#
# Image pull policy
#
#quarkus.kubernetes.image-pull-policy=Always

#
# The image pull secret
#
#quarkus.kubernetes.image-pull-secrets=

#
# The arguments
#
# @return The arguments.
#
#quarkus.kubernetes.init-containers.*.arguments=

#
# The commands
#
#quarkus.kubernetes.init-containers.*.command=

#
# The environment variable config map.
#
#quarkus.kubernetes.init-containers.*.env-vars.*.configmap=

#
# The environment variable field.
#
#quarkus.kubernetes.init-containers.*.env-vars.*.field=

#
# The environment variable name.
#
#quarkus.kubernetes.init-containers.*.env-vars.*.name=

#
# The environment variable secret.
#
#quarkus.kubernetes.init-containers.*.env-vars.*.secret=

#
# The environment variable value.
#
#quarkus.kubernetes.init-containers.*.env-vars.*.value=

#
# The host under which the application is going to be exposed.
#
#quarkus.kubernetes.init-containers.*.host=

#
# The container image.
#
#quarkus.kubernetes.init-containers.*.image=

#
# Image pull policy.
#
#quarkus.kubernetes.init-containers.*.image-pull-policy=Always

#
# The image pull secret
#
#quarkus.kubernetes.init-containers.*.image-pull-secrets=

#
# The command to use for the probe.
#
#quarkus.kubernetes.init-containers.*.liveness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.kubernetes.init-containers.*.liveness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.kubernetes.init-containers.*.liveness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.kubernetes.init-containers.*.liveness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.kubernetes.init-containers.*.liveness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.kubernetes.init-containers.*.liveness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.kubernetes.init-containers.*.liveness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.kubernetes.init-containers.*.liveness-probe.timeout=10s

#
# The name of the volumeName to mount.
#
# @return The name.
#
#quarkus.kubernetes.init-containers.*.mounts.*.name=

#
# The path to mount.
#
# @return The path.
#
#quarkus.kubernetes.init-containers.*.mounts.*.path=

#
# ReadOnly
#
# @return True if mount is readonly, False otherwise.
#
#quarkus.kubernetes.init-containers.*.mounts.*.read-only=false

#
# Path within the volumeName from which the container's volumeName should be
# mounted.
#
# @return The subPath.
#
#quarkus.kubernetes.init-containers.*.mounts.*.sub-path=

#
# The port number. Refers to the container port.
#
#quarkus.kubernetes.init-containers.*.ports.*.container-port=

#
# The host port.
#
#quarkus.kubernetes.init-containers.*.ports.*.host-port=

#
# The application path (refers to web application path).
#
# @return The path, defaults to /.
#
#quarkus.kubernetes.init-containers.*.ports.*.path=/

#
# The protocol.
#
#quarkus.kubernetes.init-containers.*.ports.*.protocol=TCP

#
# The command to use for the probe.
#
#quarkus.kubernetes.init-containers.*.readiness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.kubernetes.init-containers.*.readiness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.kubernetes.init-containers.*.readiness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.kubernetes.init-containers.*.readiness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.kubernetes.init-containers.*.readiness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.kubernetes.init-containers.*.readiness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.kubernetes.init-containers.*.readiness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.kubernetes.init-containers.*.readiness-probe.timeout=10s

#
# The service account.
#
#quarkus.kubernetes.init-containers.*.service-account=

#
# Working directory.
#
#quarkus.kubernetes.init-containers.*.working-dir=

#
# Custom labels to add to all resources
#
#quarkus.kubernetes.labels.*=

#
# The command to use for the probe.
#
#quarkus.kubernetes.liveness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.kubernetes.liveness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.kubernetes.liveness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.kubernetes.liveness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.kubernetes.liveness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.kubernetes.liveness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.kubernetes.liveness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.kubernetes.liveness-probe.timeout=10s

#
# The name of the volumeName to mount.
#
# @return The name.
#
#quarkus.kubernetes.mounts.*.name=

#
# The path to mount.
#
# @return The path.
#
#quarkus.kubernetes.mounts.*.path=

#
# ReadOnly
#
# @return True if mount is readonly, False otherwise.
#
#quarkus.kubernetes.mounts.*.read-only=false

#
# Path within the volumeName from which the container's volumeName should be
# mounted.
#
# @return The subPath.
#
#quarkus.kubernetes.mounts.*.sub-path=

#
# The name of the application. This value will be used for naming Kubernetes
# resources like: - Deployment - Service and so on ...
#
#quarkus.kubernetes.name=${quarkus.container-image.name}

#
# The name of the group this component belongs too
#
#quarkus.kubernetes.part-of=

#
# The port number. Refers to the container port.
#
#quarkus.kubernetes.ports.*.container-port=

#
# The host port.
#
#quarkus.kubernetes.ports.*.host-port=

#
# The application path (refers to web application path).
#
# @return The path, defaults to /.
#
#quarkus.kubernetes.ports.*.path=/

#
# The protocol.
#
#quarkus.kubernetes.ports.*.protocol=TCP

#
# The name of the claim to mount.
#
#quarkus.kubernetes.pvc-volumes.*.claim-name=

#
# Default mode.
# When specifying an octal number, leading zero must be present.
#
# @return The default mode.
#
#quarkus.kubernetes.pvc-volumes.*.default-mode=0600

#
# Optional
#
#quarkus.kubernetes.pvc-volumes.*.optional=false

#
# The command to use for the probe.
#
#quarkus.kubernetes.readiness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.kubernetes.readiness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.kubernetes.readiness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.kubernetes.readiness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.kubernetes.readiness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.kubernetes.readiness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.kubernetes.readiness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.kubernetes.readiness-probe.timeout=10s

#
# The number of desired pods
#
#quarkus.kubernetes.replicas=1

#
# Default mode.
# When specifying an octal number, leading zero must be present.
#
# @return The default mode.
#
#quarkus.kubernetes.secret-volumes.*.default-mode=0600

#
# Optional
#
#quarkus.kubernetes.secret-volumes.*.optional=false

#
# The name of the secret to mount.
#
#quarkus.kubernetes.secret-volumes.*.secret-name=

#
# The service account
#
#quarkus.kubernetes.service-account=

#
# The type of service that will be generated for the application
#
#quarkus.kubernetes.service-type=ClusterIP

#
# The version of the application.
#
#quarkus.kubernetes.version=${quarkus.container-image.tag}

#
# Working directory
#
#quarkus.kubernetes.working-dir=

#
# Password used to use to connect to the remote dev-mode application
#
#quarkus.live-reload.password=

#
# URL used to use to connect to the remote dev-mode application
#
#quarkus.live-reload.url=

#
# The set of supported locales that can be consumed by the extensions.
#
# The locales must be specified in the IETF BCP 47 format e.g. en-US or fr-FR.
#
# For instance, the Hibernate Validator extension makes use of it.
#
#quarkus.locales=${user.language:en}-${user.country:}

#
# The names of the handlers to link to this category.
#
#quarkus.log.category.*.handlers=

#
# The log level level for this category
#
#quarkus.log.category.*.level=inherit

#
# Specify whether or not this logger should send its output to its parent Logger
#
#quarkus.log.category.*.use-parent-handlers=true

#
# Indicates whether to log asynchronously
#
#quarkus.log.console.async=false

#
# Determine whether to block the publisher (rather than drop the message) when the queue is full
#
#quarkus.log.console.async.overflow=block

#
# The queue length to use before flushing writing
#
#quarkus.log.console.async.queue-length=512

#
# If the console logging should be in color. If undefined quarkus takes
# best guess based on operating system and environment.
# Note that this value will be ignored if an extension is present that takes
# control of console formatting (e.g. an XML or JSON-format extension).
#
#quarkus.log.console.color=

#
# Specify how much the colors should be darkened.
# Note that this value will be ignored if an extension is present that takes
# control of console formatting (e.g. an XML or JSON-format extension).
#
#quarkus.log.console.darken=0

#
# If console logging should be enabled
#
#quarkus.log.console.enable=true

#
# The log format. Note that this value will be ignored if an extension is present that takes
# control of console formatting (e.g. an XML or JSON-format extension).
#
#quarkus.log.console.format=%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) %s%e%n

#
# The console log level.
#
#quarkus.log.console.level=ALL

#
# Indicates whether to log asynchronously
#
#quarkus.log.file.async=false

#
# Determine whether to block the publisher (rather than drop the message) when the queue is full
#
#quarkus.log.file.async.overflow=block

#
# The queue length to use before flushing writing
#
#quarkus.log.file.async.queue-length=512

#
# If file logging should be enabled
#
#quarkus.log.file.enable=false

#
# The log format
#
#quarkus.log.file.format=%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{3.}] (%t) %s%e%n

#
# The level of logs to be written into the file.
#
#quarkus.log.file.level=ALL

#
# The name of the file in which logs will be written.
#
#quarkus.log.file.path=quarkus.log

#
# File handler rotation file suffix.
#
# Example fileSuffix: .yyyy-MM-dd
#
#quarkus.log.file.rotation.file-suffix=

#
# The maximum number of backups to keep.
#
#quarkus.log.file.rotation.max-backup-index=1

#
# The maximum file size of the log file after which a rotation is executed.
#
#quarkus.log.file.rotation.max-file-size=

#
# Indicates whether to rotate log files on server initialization.
#
#quarkus.log.file.rotation.rotate-on-boot=true

#
# The message starts to match
#
#quarkus.log.filter.*.if-starts-with=inherit

#
# Indicates whether to log asynchronously
#
#quarkus.log.handler.console.*.async=false

#
# Determine whether to block the publisher (rather than drop the message) when the queue is full
#
#quarkus.log.handler.console.*.async.overflow=block

#
# The queue length to use before flushing writing
#
#quarkus.log.handler.console.*.async.queue-length=512

#
# If the console logging should be in color. If undefined quarkus takes
# best guess based on operating system and environment.
# Note that this value will be ignored if an extension is present that takes
# control of console formatting (e.g. an XML or JSON-format extension).
#
#quarkus.log.handler.console.*.color=

#
# Specify how much the colors should be darkened.
# Note that this value will be ignored if an extension is present that takes
# control of console formatting (e.g. an XML or JSON-format extension).
#
#quarkus.log.handler.console.*.darken=0

#
# If console logging should be enabled
#
#quarkus.log.handler.console.*.enable=true

#
# The log format. Note that this value will be ignored if an extension is present that takes
# control of console formatting (e.g. an XML or JSON-format extension).
#
#quarkus.log.handler.console.*.format=%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) %s%e%n

#
# The console log level.
#
#quarkus.log.handler.console.*.level=ALL

#
# Indicates whether to log asynchronously
#
#quarkus.log.handler.file.*.async=false

#
# Determine whether to block the publisher (rather than drop the message) when the queue is full
#
#quarkus.log.handler.file.*.async.overflow=block

#
# The queue length to use before flushing writing
#
#quarkus.log.handler.file.*.async.queue-length=512

#
# If file logging should be enabled
#
#quarkus.log.handler.file.*.enable=false

#
# The log format
#
#quarkus.log.handler.file.*.format=%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{3.}] (%t) %s%e%n

#
# The level of logs to be written into the file.
#
#quarkus.log.handler.file.*.level=ALL

#
# The name of the file in which logs will be written.
#
#quarkus.log.handler.file.*.path=quarkus.log

#
# File handler rotation file suffix.
#
# Example fileSuffix: .yyyy-MM-dd
#
#quarkus.log.handler.file.*.rotation.file-suffix=

#
# The maximum number of backups to keep.
#
#quarkus.log.handler.file.*.rotation.max-backup-index=1

#
# The maximum file size of the log file after which a rotation is executed.
#
#quarkus.log.handler.file.*.rotation.max-file-size=

#
# Indicates whether to rotate log files on server initialization.
#
#quarkus.log.handler.file.*.rotation.rotate-on-boot=true

#
# The app name used when formatting the message in RFC5424 format
#
#quarkus.log.handler.syslog.*.app-name=

#
# Indicates whether to log asynchronously
#
#quarkus.log.handler.syslog.*.async=false

#
# Determine whether to block the publisher (rather than drop the message) when the queue is full
#
#quarkus.log.handler.syslog.*.async.overflow=block

#
# The queue length to use before flushing writing
#
#quarkus.log.handler.syslog.*.async.queue-length=512

#
# Enables or disables blocking when attempting to reconnect a
# {@link org.jboss.logmanager.handlers.SyslogHandler.Protocol#TCP
# TCP} or {@link org.jboss.logmanager.handlers.SyslogHandler.Protocol#SSL_TCP SSL TCP} protocol
#
#quarkus.log.handler.syslog.*.block-on-reconnect=false

#
# If syslog logging should be enabled
#
#quarkus.log.handler.syslog.*.enable=false

#
# The IP address and port of the syslog server
#
#quarkus.log.handler.syslog.*.endpoint=localhost:514

#
# Sets the facility used when calculating the priority of the message as defined by RFC-5424 and RFC-3164
#
#quarkus.log.handler.syslog.*.facility=user-level

#
# The log message format
#
#quarkus.log.handler.syslog.*.format=%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) %s%e%n

#
# The name of the host the messages are being sent from
#
#quarkus.log.handler.syslog.*.hostname=

#
# The log level specifying, which message levels will be logged by syslog logger
#
#quarkus.log.handler.syslog.*.level=ALL

#
# Sets the protocol used to connect to the syslog server
#
#quarkus.log.handler.syslog.*.protocol=tcp

#
# Set the {@link SyslogType syslog type} this handler should use to format the message sent
#
#quarkus.log.handler.syslog.*.syslog-type=rfc5424

#
# Set to 'true' if the message should be truncated
#
#quarkus.log.handler.syslog.*.truncate=true

#
# Set to 'true' if the message being sent should be prefixed with the size of the message
#
#quarkus.log.handler.syslog.*.use-counting-framing=false

#
# The log level of the root category, which is used as the default log level for all categories.
#
# In addition to the standard JDK log level JBoss Logging also adds the following:
#
# {@link org.jboss.logmanager.Level#FATAL}
# {@link org.jboss.logmanager.Level#ERROR}
# {@link org.jboss.logmanager.Level#WARN}
# {@link org.jboss.logmanager.Level#INFO}
# {@link org.jboss.logmanager.Level#DEBUG}
# {@link org.jboss.logmanager.Level#TRACE}
#
#quarkus.log.level=INFO

#
# The default minimum log level
#
#quarkus.log.min-level=INFO

#
# The app name used when formatting the message in RFC5424 format
#
#quarkus.log.syslog.app-name=

#
# Indicates whether to log asynchronously
#
#quarkus.log.syslog.async=false

#
# Determine whether to block the publisher (rather than drop the message) when the queue is full
#
#quarkus.log.syslog.async.overflow=block

#
# The queue length to use before flushing writing
#
#quarkus.log.syslog.async.queue-length=512

#
# Enables or disables blocking when attempting to reconnect a
# {@link org.jboss.logmanager.handlers.SyslogHandler.Protocol#TCP
# TCP} or {@link org.jboss.logmanager.handlers.SyslogHandler.Protocol#SSL_TCP SSL TCP} protocol
#
#quarkus.log.syslog.block-on-reconnect=false

#
# If syslog logging should be enabled
#
#quarkus.log.syslog.enable=false

#
# The IP address and port of the syslog server
#
#quarkus.log.syslog.endpoint=localhost:514

#
# Sets the facility used when calculating the priority of the message as defined by RFC-5424 and RFC-3164
#
#quarkus.log.syslog.facility=user-level

#
# The log message format
#
#quarkus.log.syslog.format=%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) %s%e%n

#
# The name of the host the messages are being sent from
#
#quarkus.log.syslog.hostname=

#
# The log level specifying, which message levels will be logged by syslog logger
#
#quarkus.log.syslog.level=ALL

#
# Sets the protocol used to connect to the syslog server
#
#quarkus.log.syslog.protocol=tcp

#
# Set the {@link SyslogType syslog type} this handler should use to format the message sent
#
#quarkus.log.syslog.syslog-type=rfc5424

#
# Set to 'true' if the message should be truncated
#
#quarkus.log.syslog.truncate=true

#
# Set to 'true' if the message being sent should be prefixed with the size of the message
#
#quarkus.log.syslog.use-counting-framing=false

#
# If all character sets should be added to the native image. This increases image size
#
#quarkus.native.add-all-charsets=false

#
# Additional arguments to pass to the build process
#
#quarkus.native.additional-build-args=

#
# If all META-INF/services entries should be automatically registered
#
#quarkus.native.auto-service-loader-registration=false

#
# The docker image to use to do the image build
#
#quarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-native-image:19.3.1-java11

#
# If the native image server should be restarted
#
#quarkus.native.cleanup-server=false

#
# If this build should be done using a container runtime. If this is set docker will be used by default,
# unless container-runtime is also set.
#
#quarkus.native.container-build=false

#
# The container runtime (e.g. docker) that is used to do an image based build. If this is set then
# a container build is always done.
#
#quarkus.native.container-runtime=

#
# Options to pass to the container runtime
#
#quarkus.native.container-runtime-options=

#
# If the native image build should wait for a debugger to be attached before running. This is an advanced option
# and is generally only intended for those familiar with GraalVM internals
#
#quarkus.native.debug-build-process=false

#
# If debug symbols should be included
#
#quarkus.native.debug-symbols=false

#
# If the bytecode of all proxies should be dumped for inspection
#
#quarkus.native.dump-proxies=false

#
# If all security services should be added to the native image
#
#quarkus.native.enable-all-security-services=false

#
# If a JVM based 'fallback image' should be created if native image fails. This is not recommended, as this is
# functionally the same as just running the application in a JVM
#
#quarkus.native.enable-fallback-images=false

#
# If the HTTP url handler should be enabled, allowing you to do URL.openConnection() for HTTP URLs
#
#quarkus.native.enable-http-url-handler=true

#
# If the HTTPS url handler should be enabled, allowing you to do URL.openConnection() for HTTPS URLs
#
#quarkus.native.enable-https-url-handler=false

#
# If isolates should be enabled
#
#quarkus.native.enable-isolates=true

#
# @deprecated JNI is always enabled starting from GraalVM 19.3.1.
#
#quarkus.native.enable-jni=true

#
# If the reports on call paths and included packages/classes/methods should be generated
#
#quarkus.native.enable-reports=false

#
# If the native image server should be used. This can speed up compilation but can result in changes not always
# being picked up due to cache invalidation not working 100%
#
#quarkus.native.enable-server=false

#
# If the resulting image should allow VM introspection
#
#quarkus.native.enable-vm-inspection=false

#
# If full stack traces are enabled in the resulting image
#
#quarkus.native.full-stack-traces=true

#
# The location of the Graal distribution
#
#quarkus.native.graalvm-home=${GRAALVM_HOME:}

#
# If all time zones should be added to the native image. This increases image size
#
#quarkus.native.include-all-time-zones=false

#
# The location of the JDK
#
#quarkus.native.java-home=${java.home}

#
# The maximum Java heap to be used during the native image generation
#
#quarkus.native.native-image-xmx=

#
# If the debug port should be published when building with docker and debug-build-process is true
#
#quarkus.native.publish-debug-build-process-port=true

#
# If errors should be reported at runtime. This is a more relaxed setting, however it is not recommended as it means
# your application may fail at runtime if an unsupported feature is used by accident.
#
#quarkus.native.report-errors-at-runtime=false

#
# If exceptions should be reported with a full stack trace
#
#quarkus.native.report-exception-stack-traces=true

#
# The application type, which can be one of the following values from enum {@link ApplicationType}.
#
#quarkus.oidc.*.application-type=service

#
# The base URL of the OpenID Connect (OIDC) server, for example, 'https://host:port/auth'.
# All the other OIDC server page and service URLs are derived from this URL.
# Note if you work with Keycloak OIDC server, make sure the base URL is in the following format:
# 'https://host:port/auth/realms/{realm}' where '{realm}' has to be replaced by the name of the Keycloak realm.
#
#quarkus.oidc.*.auth-server-url=

#
# Cookie path parameter value which, if set, will be used for the session and state cookies.
# It may need to be set when the redirect path has a root different to that of the original request URL.
#
#quarkus.oidc.*.authentication.cookie-path=

#
# Additional properties which will be added as the query parameters to the authentication redirect URI.
#
#quarkus.oidc.*.authentication.extra-params.*=

#
# Relative path for calculating a "redirect_uri" query parameter.
# It has to start from a forward slash and will be appended to the request URI's host and port.
# For example, if the current request URI is 'https://localhost:8080/service' then a 'redirect_uri' parameter
# will be set to 'https://localhost:8080/' if this property is set to '/' and be the same as the request URI
# if this property has not been configured.
# Note the original request URI will be restored after the user has authenticated.
#
#quarkus.oidc.*.authentication.redirect-path=

#
# If this property is set to 'true' then the original request URI which was used before
# the authentication will be restored after the user has been redirected back to the application.
#
#quarkus.oidc.*.authentication.restore-path-after-redirect=true

#
# List of scopes
#
#quarkus.oidc.*.authentication.scopes=

#
# The client-id of the application. Each application has a client-id that is used to identify the application
#
#quarkus.oidc.*.client-id=

#
# The maximum amount of time the adapter will try connecting to the currently unavailable OIDC server for.
# For example, setting it to '20S' will let the adapter keep requesting the connection for up to 20 seconds.
#
#quarkus.oidc.*.connection-delay=

#
# Authentication method.
#
#quarkus.oidc.*.credentials.client-secret.method=

#
# The client secret
#
#quarkus.oidc.*.credentials.client-secret.value=

#
# JWT life-span in seconds. It will be added to the time it was issued at to calculate the expiration time.
#
#quarkus.oidc.*.credentials.jwt.lifespan=10

#
# client_secret_jwt: JWT which includes client id as one of its claims is signed by the client secret and is
# submitted as a 'client_assertion' form parameter, while 'client_assertion_type' parameter is set to
# "urn:ietf:params:oauth:client-assertion-type:jwt-bearer".
#
#quarkus.oidc.*.credentials.jwt.secret=

#
# Client secret which is used for a 'client_secret_basic' authentication method.
# Note that a 'client-secret.value' can be used instead but both properties are mutually exclusive.
#
#quarkus.oidc.*.credentials.secret=

#
# Relative path of the RFC7662 introspection service.
#
#quarkus.oidc.*.introspection-path=

#
# Relative path of the OIDC service returning a JWK set.
#
#quarkus.oidc.*.jwks-path=

#
# The host (name or IP address) of the Proxy.<br/>
# Note: If OIDC adapter needs to use a Proxy to talk with OIDC server (Provider),
# then at least the "host" config item must be configured to enable the usage of a Proxy.
#
#quarkus.oidc.*.proxy.host=

#
# The password, if Proxy needs authentication.
#
#quarkus.oidc.*.proxy.password=

#
# The port number of the Proxy. Default value is 80.
#
#quarkus.oidc.*.proxy.port=80

#
# The username, if Proxy needs authentication.
#
#quarkus.oidc.*.proxy.username=

#
# Public key for the local JWT token verification.
#
#quarkus.oidc.*.public-key=

#
# Path to the claim containing an array of groups. It starts from the top level JWT JSON object and
# can contain multiple segments where each segment represents a JSON object name only, example: "realm/groups".
# Use double quotes with the namespace qualified claim names.
# This property can be used if a token has no 'groups' claim but has the groups set in a different claim.
#
#quarkus.oidc.*.roles.role-claim-path=

#
# Separator for splitting a string which may contain multiple group values.
# It will only be used if the "role-claim-path" property points to a custom claim whose value is a string.
# A single space will be used by default because the standard 'scope' claim may contain a space separated sequence.
#
#quarkus.oidc.*.roles.role-claim-separator=

#
# If this tenant configuration is enabled.
#
#quarkus.oidc.*.tenant-enabled=true

#
# A unique tenant identifier. It must be set by 'TenantConfigResolver' providers which
# resolve the tenant configuration dynamically and is optional in all other cases.
#
#quarkus.oidc.*.tenant-id=

#
# Certificate validation and hostname verification, which can be one of the following values from enum
# {@link Verification}. Default is required.
#
#quarkus.oidc.*.tls.verification=REQUIRED

#
# Expected audience 'aud' claim value which may be a string or an array of strings.
#
#quarkus.oidc.*.token.audience=

#
# Expiration grace period in seconds. A token expiration time will be reduced by
# the value of this property before being compared to the current time.
#
#quarkus.oidc.*.token.expiration-grace=

#
# Expected issuer 'iss' claim value.
#
#quarkus.oidc.*.token.issuer=

#
# Name of the claim which contains a principal name. By default, the 'upn', 'preferred_username' and `sub` claims are
# checked.
#
#quarkus.oidc.*.token.principal-claim=

#
# The application type, which can be one of the following values from enum {@link ApplicationType}.
#
#quarkus.oidc.application-type=service

#
# The base URL of the OpenID Connect (OIDC) server, for example, 'https://host:port/auth'.
# All the other OIDC server page and service URLs are derived from this URL.
# Note if you work with Keycloak OIDC server, make sure the base URL is in the following format:
# 'https://host:port/auth/realms/{realm}' where '{realm}' has to be replaced by the name of the Keycloak realm.
#
quarkus.oidc.auth-server-url=${authurl}

#
# Cookie path parameter value which, if set, will be used for the session and state cookies.
# It may need to be set when the redirect path has a root different to that of the original request URL.
#
#quarkus.oidc.authentication.cookie-path=

#
# Additional properties which will be added as the query parameters to the authentication redirect URI.
#
#quarkus.oidc.authentication.extra-params.*=

#
# Relative path for calculating a "redirect_uri" query parameter.
# It has to start from a forward slash and will be appended to the request URI's host and port.
# For example, if the current request URI is 'https://localhost:8080/service' then a 'redirect_uri' parameter
# will be set to 'https://localhost:8080/' if this property is set to '/' and be the same as the request URI
# if this property has not been configured.
# Note the original request URI will be restored after the user has authenticated.
#
#quarkus.oidc.authentication.redirect-path=

#
# If this property is set to 'true' then the original request URI which was used before
# the authentication will be restored after the user has been redirected back to the application.
#
#quarkus.oidc.authentication.restore-path-after-redirect=true

#
# List of scopes
#
#quarkus.oidc.authentication.scopes=

#
# The client-id of the application. Each application has a client-id that is used to identify the application
#
quarkus.oidc.client-id=${authClientId}

#
# The maximum amount of time the adapter will try connecting to the currently unavailable OIDC server for.
# For example, setting it to '20S' will let the adapter keep requesting the connection for up to 20 seconds.
#
#quarkus.oidc.connection-delay=

#
# Authentication method.
#
#quarkus.oidc.credentials.client-secret.method=

#
# The client secret
#
#quarkus.oidc.credentials.client-secret.value=

#
# JWT life-span in seconds. It will be added to the time it was issued at to calculate the expiration time.
#
#quarkus.oidc.credentials.jwt.lifespan=10

#
# client_secret_jwt: JWT which includes client id as one of its claims is signed by the client secret and is
# submitted as a 'client_assertion' form parameter, while 'client_assertion_type' parameter is set to
# "urn:ietf:params:oauth:client-assertion-type:jwt-bearer".
#
#quarkus.oidc.credentials.jwt.secret=

#
# Client secret which is used for a 'client_secret_basic' authentication method.
# Note that a 'client-secret.value' can be used instead but both properties are mutually exclusive.
#
quarkus.oidc.credentials.secret=${authClientSecret}

#
# If the OIDC extension is enabled.
#
quarkus.oidc.enabled=true

#
# Relative path of the RFC7662 introspection service.
#
#quarkus.oidc.introspection-path=

#
# Relative path of the OIDC service returning a JWK set.
#
#quarkus.oidc.jwks-path=

#
# The host (name or IP address) of the Proxy.<br/>
# Note: If OIDC adapter needs to use a Proxy to talk with OIDC server (Provider),
# then at least the "host" config item must be configured to enable the usage of a Proxy.
#
#quarkus.oidc.proxy.host=

#
# The password, if Proxy needs authentication.
#
#quarkus.oidc.proxy.password=

#
# The port number of the Proxy. Default value is 80.
#
#quarkus.oidc.proxy.port=80

#
# The username, if Proxy needs authentication.
#
#quarkus.oidc.proxy.username=

#
# Public key for the local JWT token verification.
#
#quarkus.oidc.public-key=

#
# Path to the claim containing an array of groups. It starts from the top level JWT JSON object and
# can contain multiple segments where each segment represents a JSON object name only, example: "realm/groups".
# Use double quotes with the namespace qualified claim names.
# This property can be used if a token has no 'groups' claim but has the groups set in a different claim.
#
#quarkus.oidc.roles.role-claim-path=

#
# Separator for splitting a string which may contain multiple group values.
# It will only be used if the "role-claim-path" property points to a custom claim whose value is a string.
# A single space will be used by default because the standard 'scope' claim may contain a space separated sequence.
#
#quarkus.oidc.roles.role-claim-separator=

#
# If this tenant configuration is enabled.
#
#quarkus.oidc.tenant-enabled=true

#
# A unique tenant identifier. It must be set by 'TenantConfigResolver' providers which
# resolve the tenant configuration dynamically and is optional in all other cases.
#
#quarkus.oidc.tenant-id=

#
# Certificate validation and hostname verification, which can be one of the following values from enum
# {@link Verification}. Default is required.
#
#quarkus.oidc.tls.verification=REQUIRED

#
# Expected audience 'aud' claim value which may be a string or an array of strings.
#
#quarkus.oidc.token.audience=

#
# Expiration grace period in seconds. A token expiration time will be reduced by
# the value of this property before being compared to the current time.
#
#quarkus.oidc.token.expiration-grace=

#
# Expected issuer 'iss' claim value.
#
#quarkus.oidc.token.issuer=

#
# Name of the claim which contains a principal name. By default, the 'upn', 'preferred_username' and `sub` claims are
# checked.
#
#quarkus.oidc.token.principal-claim=

#
# Whether or not to add the build timestamp to the Kubernetes annotations
# This is a very useful way to have manifests of successive builds of the same
# application differ - thus ensuring that Kubernetes will apply the updated resources
#
#quarkus.openshift.add-build-timestamp=true

#
# Custom annotations to add to all resources
#
#quarkus.openshift.annotations.*=

#
# The arguments
#
# @return The arguments
#
#quarkus.openshift.arguments=

#
# Filesystem type.
#
#quarkus.openshift.aws-elastic-block-store-volumes.*.fs-type=ext4

#
# The partition.
#
#quarkus.openshift.aws-elastic-block-store-volumes.*.partition=

#
# Wether the volumeName is read only or not.
#
#quarkus.openshift.aws-elastic-block-store-volumes.*.read-only=false

#
# The name of the disk to mount.
#
#quarkus.openshift.aws-elastic-block-store-volumes.*.volume-id=

#
# Disk caching mode.
#
#quarkus.openshift.azure-disk-volumes.*.caching-mode=ReadWrite

#
# The name of the disk to mount.
#
#quarkus.openshift.azure-disk-volumes.*.disk-name=

#
# The URI of the vhd blob object OR the resourceID of an Azure managed data disk if Kind is Managed
#
#quarkus.openshift.azure-disk-volumes.*.disk-uri=

#
# File system type.
#
#quarkus.openshift.azure-disk-volumes.*.fs-type=ext4

#
# Kind of disk.
#
#quarkus.openshift.azure-disk-volumes.*.kind=Managed

#
# Wether the volumeName is read only or not.
#
#quarkus.openshift.azure-disk-volumes.*.read-only=false

#
# Wether the volumeName is read only or not.
#
#quarkus.openshift.azure-file-volumes.*.read-only=false

#
# The secret name.
#
#quarkus.openshift.azure-file-volumes.*.secret-name=

#
# The share name.
#
#quarkus.openshift.azure-file-volumes.*.share-name=

#
# The commands
#
#quarkus.openshift.command=

#
# The name of the ConfigMap to mount.
#
#quarkus.openshift.config-map-volumes.*.config-map-name=

#
# Default mode.
# When specifying an octal number, leading zero must be present.
#
# @return The default mode.
#
#quarkus.openshift.config-map-volumes.*.default-mode=0600

#
# Optional
#
#quarkus.openshift.config-map-volumes.*.optional=false

#
# The arguments
#
# @return The arguments.
#
#quarkus.openshift.containers.*.arguments=

#
# The commands
#
#quarkus.openshift.containers.*.command=

#
# The environment variable config map.
#
#quarkus.openshift.containers.*.env-vars.*.configmap=

#
# The environment variable field.
#
#quarkus.openshift.containers.*.env-vars.*.field=

#
# The environment variable name.
#
#quarkus.openshift.containers.*.env-vars.*.name=

#
# The environment variable secret.
#
#quarkus.openshift.containers.*.env-vars.*.secret=

#
# The environment variable value.
#
#quarkus.openshift.containers.*.env-vars.*.value=

#
# The host under which the application is going to be exposed.
#
#quarkus.openshift.containers.*.host=

#
# The container image.
#
#quarkus.openshift.containers.*.image=

#
# Image pull policy.
#
#quarkus.openshift.containers.*.image-pull-policy=Always

#
# The image pull secret
#
#quarkus.openshift.containers.*.image-pull-secrets=

#
# The command to use for the probe.
#
#quarkus.openshift.containers.*.liveness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.openshift.containers.*.liveness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.openshift.containers.*.liveness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.openshift.containers.*.liveness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.openshift.containers.*.liveness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.openshift.containers.*.liveness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.openshift.containers.*.liveness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.openshift.containers.*.liveness-probe.timeout=10s

#
# The name of the volumeName to mount.
#
# @return The name.
#
#quarkus.openshift.containers.*.mounts.*.name=

#
# The path to mount.
#
# @return The path.
#
#quarkus.openshift.containers.*.mounts.*.path=

#
# ReadOnly
#
# @return True if mount is readonly, False otherwise.
#
#quarkus.openshift.containers.*.mounts.*.read-only=false

#
# Path within the volumeName from which the container's volumeName should be
# mounted.
#
# @return The subPath.
#
#quarkus.openshift.containers.*.mounts.*.sub-path=

#
# The port number. Refers to the container port.
#
#quarkus.openshift.containers.*.ports.*.container-port=

#
# The host port.
#
#quarkus.openshift.containers.*.ports.*.host-port=

#
# The application path (refers to web application path).
#
# @return The path, defaults to /.
#
#quarkus.openshift.containers.*.ports.*.path=/

#
# The protocol.
#
#quarkus.openshift.containers.*.ports.*.protocol=TCP

#
# The command to use for the probe.
#
#quarkus.openshift.containers.*.readiness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.openshift.containers.*.readiness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.openshift.containers.*.readiness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.openshift.containers.*.readiness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.openshift.containers.*.readiness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.openshift.containers.*.readiness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.openshift.containers.*.readiness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.openshift.containers.*.readiness-probe.timeout=10s

#
# The service account.
#
#quarkus.openshift.containers.*.service-account=

#
# Working directory.
#
#quarkus.openshift.containers.*.working-dir=

#
# The environment variable config map.
#
#quarkus.openshift.env-vars.*.configmap=

#
# The environment variable field.
#
#quarkus.openshift.env-vars.*.field=

#
# The environment variable name.
#
#quarkus.openshift.env-vars.*.name=

#
# The environment variable secret.
#
#quarkus.openshift.env-vars.*.secret=

#
# The environment variable value.
#
#quarkus.openshift.env-vars.*.value=

#
# If true, an Openshift Route will be created
#
#quarkus.openshift.expose=false

#
# The directory of the repository to mount.
#
#quarkus.openshift.git-repo-volumes.*.directory=

#
# Git repoistory URL.
#
#quarkus.openshift.git-repo-volumes.*.repository=

#
# The commit hash to use.
#
#quarkus.openshift.git-repo-volumes.*.revision=

#
# The host under which the application is going to be exposed
#
#quarkus.openshift.host=

#
# Image pull policy
#
#quarkus.openshift.image-pull-policy=Always

#
# The image pull secret
#
#quarkus.openshift.image-pull-secrets=

#
# The arguments
#
# @return The arguments.
#
#quarkus.openshift.init-containers.*.arguments=

#
# The commands
#
#quarkus.openshift.init-containers.*.command=

#
# The environment variable config map.
#
#quarkus.openshift.init-containers.*.env-vars.*.configmap=

#
# The environment variable field.
#
#quarkus.openshift.init-containers.*.env-vars.*.field=

#
# The environment variable name.
#
#quarkus.openshift.init-containers.*.env-vars.*.name=

#
# The environment variable secret.
#
#quarkus.openshift.init-containers.*.env-vars.*.secret=

#
# The environment variable value.
#
#quarkus.openshift.init-containers.*.env-vars.*.value=

#
# The host under which the application is going to be exposed.
#
#quarkus.openshift.init-containers.*.host=

#
# The container image.
#
#quarkus.openshift.init-containers.*.image=

#
# Image pull policy.
#
#quarkus.openshift.init-containers.*.image-pull-policy=Always

#
# The image pull secret
#
#quarkus.openshift.init-containers.*.image-pull-secrets=

#
# The command to use for the probe.
#
#quarkus.openshift.init-containers.*.liveness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.openshift.init-containers.*.liveness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.openshift.init-containers.*.liveness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.openshift.init-containers.*.liveness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.openshift.init-containers.*.liveness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.openshift.init-containers.*.liveness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.openshift.init-containers.*.liveness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.openshift.init-containers.*.liveness-probe.timeout=10s

#
# The name of the volumeName to mount.
#
# @return The name.
#
#quarkus.openshift.init-containers.*.mounts.*.name=

#
# The path to mount.
#
# @return The path.
#
#quarkus.openshift.init-containers.*.mounts.*.path=

#
# ReadOnly
#
# @return True if mount is readonly, False otherwise.
#
#quarkus.openshift.init-containers.*.mounts.*.read-only=false

#
# Path within the volumeName from which the container's volumeName should be
# mounted.
#
# @return The subPath.
#
#quarkus.openshift.init-containers.*.mounts.*.sub-path=

#
# The port number. Refers to the container port.
#
#quarkus.openshift.init-containers.*.ports.*.container-port=

#
# The host port.
#
#quarkus.openshift.init-containers.*.ports.*.host-port=

#
# The application path (refers to web application path).
#
# @return The path, defaults to /.
#
#quarkus.openshift.init-containers.*.ports.*.path=/

#
# The protocol.
#
#quarkus.openshift.init-containers.*.ports.*.protocol=TCP

#
# The command to use for the probe.
#
#quarkus.openshift.init-containers.*.readiness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.openshift.init-containers.*.readiness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.openshift.init-containers.*.readiness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.openshift.init-containers.*.readiness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.openshift.init-containers.*.readiness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.openshift.init-containers.*.readiness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.openshift.init-containers.*.readiness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.openshift.init-containers.*.readiness-probe.timeout=10s

#
# The service account.
#
#quarkus.openshift.init-containers.*.service-account=

#
# Working directory.
#
#quarkus.openshift.init-containers.*.working-dir=

#
# Custom labels to add to all resources
#
#quarkus.openshift.labels.*=

#
# The command to use for the probe.
#
#quarkus.openshift.liveness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.openshift.liveness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.openshift.liveness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.openshift.liveness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.openshift.liveness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.openshift.liveness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.openshift.liveness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.openshift.liveness-probe.timeout=10s

#
# The name of the volumeName to mount.
#
# @return The name.
#
#quarkus.openshift.mounts.*.name=

#
# The path to mount.
#
# @return The path.
#
#quarkus.openshift.mounts.*.path=

#
# ReadOnly
#
# @return True if mount is readonly, False otherwise.
#
#quarkus.openshift.mounts.*.read-only=false

#
# Path within the volumeName from which the container's volumeName should be
# mounted.
#
# @return The subPath.
#
#quarkus.openshift.mounts.*.sub-path=

#
# The name of the application. This value will be used for naming Kubernetes
# resources like: - Deployment - Service and so on ...
#
#quarkus.openshift.name=${quarkus.container-image.name}

#
# The name of the group this component belongs too
#
#quarkus.openshift.part-of=

#
# The port number. Refers to the container port.
#
#quarkus.openshift.ports.*.container-port=

#
# The host port.
#
#quarkus.openshift.ports.*.host-port=

#
# The application path (refers to web application path).
#
# @return The path, defaults to /.
#
#quarkus.openshift.ports.*.path=/

#
# The protocol.
#
#quarkus.openshift.ports.*.protocol=TCP

#
# The name of the claim to mount.
#
#quarkus.openshift.pvc-volumes.*.claim-name=

#
# Default mode.
# When specifying an octal number, leading zero must be present.
#
# @return The default mode.
#
#quarkus.openshift.pvc-volumes.*.default-mode=0600

#
# Optional
#
#quarkus.openshift.pvc-volumes.*.optional=false

#
# The command to use for the probe.
#
#quarkus.openshift.readiness-probe.exec-action=

#
# The failure threshold to use.
#
#quarkus.openshift.readiness-probe.failure-threshold=3

#
# The http path to use for the probe For this to work, the container port also
# needs to be set
#
# Assuming the container port has been set (as per above comment), if
# execAction or tcpSocketAction are not set, an http probe will be used
# automatically even if no path is set (which will result in the root path
# being used)
#
#quarkus.openshift.readiness-probe.http-action-path=

#
# The amount of time to wait before starting to probe.
#
#quarkus.openshift.readiness-probe.initial-delay=0

#
# The period in which the action should be called.
#
#quarkus.openshift.readiness-probe.period=30s

#
# The success threshold to use.
#
#quarkus.openshift.readiness-probe.success-threshold=1

#
# The tcp socket to use for the probe (the format is host:port).
#
#quarkus.openshift.readiness-probe.tcp-socket-action=

#
# The amount of time to wait for each action.
#
#quarkus.openshift.readiness-probe.timeout=10s

#
# The number of desired pods
#
#quarkus.openshift.replicas=1

#
# Default mode.
# When specifying an octal number, leading zero must be present.
#
# @return The default mode.
#
#quarkus.openshift.secret-volumes.*.default-mode=0600

#
# Optional
#
#quarkus.openshift.secret-volumes.*.optional=false

#
# The name of the secret to mount.
#
#quarkus.openshift.secret-volumes.*.secret-name=

#
# The service account
#
#quarkus.openshift.service-account=

#
# The type of service that will be generated for the application
#
#quarkus.openshift.service-type=ClusterIP

#
# The version of the application.
#
#quarkus.openshift.version=${quarkus.container-image.tag}

#
# Working directory
#
#quarkus.openshift.working-dir=

#
# The entry point of the application. This can either be a a fully qualified name of a standard Java
# class with a main method, or {@link io.quarkus.runtime.QuarkusApplication}.
#
# If your application has main classes annotated with {@link io.quarkus.runtime.annotations.QuarkusMain}
# then this can also reference the name given in the annotation, to avoid the need to specify fully qualified
# names in the config.
#
#quarkus.package.main-class=

#
# If the Implementation information should be included in the runner jar's MANIFEST.MF.
#
#quarkus.package.manifest.add-implementation-entries=true

#
# Custom manifest sections to be added to the MANIFEST.MF file.
# An example of the user defined property:
# quarkus.package.manifest.manifest-sections.{Section-Name}.{Entry-Key1}={Value1}
# quarkus.package.manifest.manifest-sections.{Section-Name}.{Entry-Key2}={Value2}
#
#quarkus.package.manifest.manifest-sections.*.*=

#
# The output folder in which to place the output, this is resolved relative to the build
# systems target directory.
#
#quarkus.package.output-directory=

#
# The name of the final artifact
#
#quarkus.package.output-name=

#
# The suffix that is applied to the runner jar and native images
#
#quarkus.package.runner-suffix=-runner

#
# The requested output type.
#
# The default built in types are jar and native
#
#quarkus.package.type=jar

#
# If the java runner should be packed as an uberjar
#
#quarkus.package.uber-jar=false

#
# Files that should not be copied to the output artifact
#
#quarkus.package.user-configured-ignored-entries=

#
# artifactId of the platform to use
#
#quarkus.platform.artifact-id=quarkus-universe-bom

#
# groupId of the platform to use
#
#quarkus.platform.group-id=io.quarkus

#
# version of the platform to use
#
#quarkus.platform.version=999-SNAPSHOT

#
# Profile that will be active when Quarkus launches
#
#quarkus.profile=prod

#
# If gzip is enabled
#
#quarkus.resteasy.gzip.enabled=false

#
# Maximum deflated file bytes size
#
# If the limit is exceeded, Resteasy will return Response
# with status 413("Request Entity Too Large")
#
#quarkus.resteasy.gzip.max-input=10M

#
# Whether or not JAX-RS metrics should be enabled if the Metrics capability is present and Vert.x is being used.
#
#quarkus.resteasy.metrics.enabled=false

#
# Set this to override the default path for JAX-RS resources if there are no
# annotated application classes.
#
#quarkus.resteasy.path=/

#
# If this is true then JAX-RS will use only a single instance of a resource
# class to service all requests.
#
# If this is false then it will create a new instance of the resource per
# request.
#
# If the resource class has an explicit CDI scope annotation then the value of
# this annotation will always be used to control the lifecycle of the resource
# class.
#
# IMPLEMENTATION NOTE: 'javax.ws.rs.Path' turns into a CDI stereotype
# with singleton scope. As a result, if a user annotates a JAX-RS resource with
# a stereotype which has a different default scope the deployment fails with
# IllegalStateException.
#
#quarkus.resteasy.singleton-resources=true

#
# If set to true, access to all methods of beans that have any security annotations on other members will be denied by
# default.
# E.g. if enabled, in the following bean, <code>methodB</code> will be denied.
#
# <pre>
# {@literal @}ApplicationScoped
# public class A {
# {@literal @}RolesAllowed("admin")
# public void methodA() {
# ...
# }
# public void methodB() {
# ...
# }
# }
# </pre>
#
#quarkus.security.deny-unannotated-members=false

#
# if set to true, access to all JAX-RS resources will be denied by default
#
#quarkus.security.jaxrs.deny-unannotated-endpoints=false

#
# List of security providers to enable for reflection
#
#quarkus.security.security-providers=

#
# The timeout to wait for running requests to finish. If this is not set then the application will exit immediately.
#
# Setting this timeout will incur a small performance penalty, as it requires active requests to be tracked.
#
#quarkus.shutdown.timeout=

#
# The relative path of the health group endpoint.
#
#quarkus.smallrye-health.group-path=/group

#
# The relative path of the liveness health-checking endpoint.
#
#quarkus.smallrye-health.liveness-path=/live

#
# The relative path of the readiness health-checking endpoint.
#
#quarkus.smallrye-health.readiness-path=/ready

#
# Root path for health-checking endpoints.
#
#quarkus.smallrye-health.root-path=/health

#
# Whether or not metrics published by Quarkus extensions should be enabled.
#
#quarkus.smallrye-metrics.extensions.enabled=true

#
# Apply Micrometer compatibility mode, where instead of regular 'base' and 'vendor' metrics,
# Quarkus exposes the same 'jvm' metrics that Micrometer does. Application metrics are unaffected by this mode.
# The use case is to facilitate migration from Micrometer-based metrics, because original dashboards for JVM metrics
# will continue working without having to rewrite them.
#
#quarkus.smallrye-metrics.micrometer.compatibility=false

#
# The path to the metrics handler.
#
#quarkus.smallrye-metrics.path=/metrics

#
# The path at which to register the OpenAPI Servlet.
#
#quarkus.smallrye-openapi.path=/openapi

#
# Enable native SSL support.
#
#quarkus.ssl.native=

#
# If this should be included every time. By default this is only included when the application is running
# in dev mode.
#
#quarkus.swagger-ui.always-include=false

#
# If Swagger UI should be enabled. By default, Swagger UI is enabled.
#
#quarkus.swagger-ui.enable=true

#
# The path where Swagger UI is available.
#
# The value `/` is not allowed as it blocks the application from serving anything else.
#
#quarkus.swagger-ui.path=/swagger-ui

#
# The profile to use when testing the native image
#
#quarkus.test.native-image-profile=prod

#
# Duration to wait for the native image to built during testing
#
#quarkus.test.native-image-wait-time=PT5M

#
# The profile to use when testing using @QuarkusTest
#
#quarkus.test.profile=test

#
# The core thread pool size. This number of threads will always be kept alive.
#
#quarkus.thread-pool.core-threads=1

#
# The executor growth resistance.
#
# A resistance factor applied after the core pool is full; values applied here will cause that fraction
# of submissions to create new threads when no idle thread is available. A value of '0.0f' implies that
# threads beyond the core size should be created as aggressively as threads within it; a value of '1.0f'
# implies that threads beyond the core size should never be created.
#
#quarkus.thread-pool.growth-resistance=0

#
# The amount of time a thread will stay alive with no work.
#
#quarkus.thread-pool.keep-alive-time=30

#
# The maximum number of threads. If this is not specified then
# it will be automatically sized to 8 * the number of available processors
#
#quarkus.thread-pool.max-threads=

#
# Prefill core thread pool.
# The core thread pool will be initialised with the core number of threads at startup
#
#quarkus.thread-pool.prefill=true

#
# The queue size. For most applications this should be unbounded
#
#quarkus.thread-pool.queue-size=

#
# The frequency at which the status of the thread pool should be checked during shutdown. Information about
# waiting tasks and threads will be checked and possibly logged at this interval. Setting this key to an empty
# value disables the shutdown check interval.
#
#quarkus.thread-pool.shutdown-check-interval=5

#
# The amount of time to wait for thread pool shutdown before tasks should be interrupted. If this value is
# greater than or equal to the value for 'shutdown-timeout', then tasks will not be interrupted before
# the shutdown timeout occurs.
#
#quarkus.thread-pool.shutdown-interrupt=10

#
# The shutdown timeout. If all pending work has not been completed by this time
# then additional threads will be spawned to attempt to finish any pending tasks, and the shutdown process will
# continue
#
#quarkus.thread-pool.shutdown-timeout=1M

#
# The default transaction timeout
#
#quarkus.transaction-manager.default-transaction-timeout=60

#
# The node name used by the transaction manager
#
#quarkus.transaction-manager.node-name=quarkus

#
# Role Id for AppRole auth method. This property is required when selecting the app-role authentication type.
#
#quarkus.vault.authentication.app-role.role-id=

#
# Secret Id for AppRole auth method. This property is required when selecting the app-role authentication type.
#
#quarkus.vault.authentication.app-role.secret-id=

#
# Wrapping token containing a Secret Id, obtained from:
#
# vault write -wrap-ttl=60s -f auth/approle/role/myapp/secret-id
#
# secret-id and secret-id-wrapping-token are exclusive
#
#quarkus.vault.authentication.app-role.secret-id-wrapping-token=

#
# Vault token, bypassing Vault authentication (kubernetes, userpass or approle). This is useful in development
# where an authentication mode might not have been set up. In production we will usually prefer some
# authentication such as userpass, or preferably kubernetes, where Vault tokens get generated with a TTL
# and some ability to revoke them. Lease renewal does not apply.
#
quarkus.vault.authentication.client-token=y2api

#
# Client token wrapped in a wrapping token, such as what is returned by:
#
# vault token create -wrap-ttl=60s -policy=myapp
#
# client-token and client-token-wrapping-token are exclusive. Lease renewal does not apply.
#
#quarkus.vault.authentication.client-token-wrapping-token=

#
# Location of the file containing the Kubernetes JWT token to authenticate against
# in Kubernetes authentication mode.
#
#quarkus.vault.authentication.kubernetes.jwt-token-path=/var/run/secrets/kubernetes.io/serviceaccount/token

#
# Kubernetes authentication role that has been created in Vault to associate Vault policies, with
# Kubernetes service accounts and/or Kubernetes namespaces. This property is required when selecting
# the Kubernetes authentication type.
#
#quarkus.vault.authentication.kubernetes.role=

#
# Password for userpass auth method. This property is required when selecting the userpass authentication type.
#
#quarkus.vault.authentication.userpass.password=

#
# Wrapping token containing a Password, obtained from:
#
# vault kv get -wrap-ttl=60s secret/<path>
#
# The key has to be 'password', meaning the password has initially been provisioned with:
#
# vault kv put secret/<path> password=<password value>
#
# password and password-wrapping-token are exclusive
#
#quarkus.vault.authentication.userpass.password-wrapping-token=

#
# User for userpass auth method. This property is required when selecting the userpass authentication type.
#
#quarkus.vault.authentication.userpass.username=

#
# Timeout to establish a connection with Vault.
#
#quarkus.vault.connect-timeout=5S

#
# Database credentials role, as defined by https://www.vaultproject.io/docs/secrets/databases/index.html
#
# One of `database-credentials-role` or `kv-path` needs to be defined. not both.
#
# @asciidoclet
#
#quarkus.vault.credentials-provider.*.database-credentials-role=

#
# Key name to search in vault path `kv-path`. The value for that key is the credential.
#
# `kv-key` should not be defined if `kv-path` is not.
#
# see https://www.vaultproject.io/docs/secrets/kv/index.html
#
# @asciidoclet
#
#quarkus.vault.credentials-provider.*.kv-key=password

#
# A path in vault kv store, where we will find the kv-key.
#
# One of `database-credentials-role` or `kv-path` needs to be defined. not both.
#
# see https://www.vaultproject.io/docs/secrets/kv/index.html
#
# @asciidoclet
#
#quarkus.vault.credentials-provider.cmf01.kv-path=y2api/db

#
# Whether or not an health check is published in case the smallrye-health extension is present.
#
#quarkus.vault.health.enabled=false

#
# Specifies if being a performance standby should still return the active status code instead of the performance standby
# status code.
#
#quarkus.vault.health.performance-stand-by-ok=false

#
# Specifies if being a standby should still return the active status code instead of the standby status code.
#
#quarkus.vault.health.stand-by-ok=false

#
# KV secret engine path.
#
# This value is used when building the url path in the KV secret engine programmatic access
# (i.e. `VaultKVSecretEngine`) and the vault config source (i.e. fetching configuration properties from Vault).
#
# For a v2 KV secret engine (default - see `kv-secret-engine-version property`)
# the full url is built from the expression `<url>/v1/</kv-secret-engine-mount-path>/data/...`.
#
# With property `quarkus.vault.url=https://localhost:8200`, the following call
# `vaultKVSecretEngine.readSecret("foo/bar")` would lead eventually to a `GET` on Vault with the following
# url: `https://localhost:8200/v1/secret/data/foo/bar`.
#
# With a KV secret engine v1, the url changes to: `<url>/v1/</kv-secret-engine-mount-path>/...`.
#
# The same logic is applied to the Vault config source. With `quarkus.vault.secret-config-kv-path=config/myapp`
# The secret properties would be fetched from Vault using a `GET` on
# `https://localhost:8200/v1/secret/data/config/myapp` for a KV secret engine v2 (or
# `https://localhost:8200/v1/secret/config/myapp` for a KV secret engine v1).
#
# see https://www.vaultproject.io/docs/secrets/kv/index.html
#
# @asciidoclet
#
#quarkus.vault.kv-secret-engine-mount-path=secret

#
# Kv secret engine version.
#
# see https://www.vaultproject.io/docs/secrets/kv/index.html
#
# @asciidoclet
#
#quarkus.vault.kv-secret-engine-version=2

#
# Used to hide confidential infos, for logging in particular.
# Possible values are:
#
# * low: display all secrets.
# * medium: display only usernames and lease ids (ie: passwords and tokens are masked).
# * high: hide lease ids and dynamic credentials username.
#
# @asciidoclet
#
#quarkus.vault.log-confidentiality-level=medium

#
# Request timeout on Vault.
#
#quarkus.vault.read-timeout=1S

#
# Renew grace period duration.
#
# This value if used to extend a lease before it expires its ttl, or recreate a new lease before the current
# lease reaches its max_ttl.
# By default Vault leaseDuration is equal to 7 days (ie: 168h or 604800s).
# If a connection pool maxLifetime is set, it is reasonable to set the renewGracePeriod to be greater
# than the maxLifetime, so that we are sure we get a chance to renew leases before we reach the ttl.
# In any case you need to make sure there will be attempts to fetch secrets within the renewGracePeriod,
# because that is when the renewals will happen. This is particularly important for db dynamic secrets
# because if the lease reaches its ttl or max_ttl, the password of the db user will become invalid and
# it will be not longer possible to log in.
# This value should also be smaller than the ttl, otherwise that would mean that we would try to recreate
# leases all the time.
#
# @asciidoclet
#
#quarkus.vault.renew-grace-period=1H

#
# Vault config source cache period.
#
# Properties fetched from vault as MP config will be kept in a cache, and will not be fetched from vault
# again until the expiration of that period.
# This property is ignored if `secret-config-kv-path` is not set.
#
# @asciidoclet
#
#quarkus.vault.secret-config-cache-period=10M

#
# List of comma separated vault paths in kv store,
# where all properties will be available as MP config properties **as-is**, with no prefix.
#
# For instance, if vault contains property `foo`, it will be made available to the
# quarkus application as `@ConfigProperty(name = "foo") String foo;`
#
# If 2 paths contain the same property, the last path will win.
#
# For instance if
#
# * `secret/base-config` contains `foo=bar` and
# * `secret/myapp/config` contains `foo=myappbar`, then
#
# `@ConfigProperty(name = "foo") String foo` will have value `myappbar`
# with application properties `quarkus.vault.secret-config-kv-path=base-config,myapp/config`
#
# See also the documentation for the `kv-secret-engine-mount-path` property for some insights on how
# the full Vault url gets built.
#
# @asciidoclet
#
quarkus.vault.secret-config-kv-path=y2api/jt400

#
# List of comma separated vault paths in kv store,
# where all properties will be available as **prefixed** MP config properties.
#
# For instance if the application properties contains
# `quarkus.vault.secret-config-kv-path.myprefix=config`, and
# vault path `secret/config` contains `foo=bar`, then `myprefix.foo`
# will be available in the MP config.
#
# If the same property is available in 2 different paths for the same prefix, the last one
# will win.
#
# See also the documentation for the `kv-secret-engine-mount-path` property for some insights on how
# the full Vault url gets built.
#
# @asciidoclet
#
#quarkus.vault.secret-config-kv-path."prefix".*=

#
# Certificate bundle used to validate TLS communications with Vault.
#
# The path to a pem bundle file, if TLS is required, and trusted certificates are not set through
# javax.net.ssl.trustStore system property.
#
#quarkus.vault.tls.ca-cert=

#
# Allows to bypass certificate validation on TLS communications.
#
# If true this will allow TLS communications with Vault, without checking the validity of the
# certificate presented by Vault. This is discouraged in production because it allows man in the middle
# type of attacks.
#
#quarkus.vault.tls.skip-verify=false

#
# If true and Vault authentication type is kubernetes, TLS will be active and the cacert path will
# be set to /var/run/secrets/kubernetes.io/serviceaccount/ca.crt. If set, this setting will take precedence
# over property quarkus.vault.tls.ca-cert. This means that if Vault authentication type is kubernetes
# and we want to use quarkus.vault.tls.ca-cert or system property javax.net.ssl.trustStore, then this
# property should be set to false.
#
#quarkus.vault.tls.use-kubernetes-ca-cert=true

#
# If enabled, the key will support convergent encryption, where the same plaintext creates the same ciphertext.
# Applies to encrypt operations.
#
# @see <a href="https://www.vaultproject.io/api/secret/transit/index.html#convergent_encryption">api documentation for
# convergent_encryption</a>
#
#quarkus.vault.transit.key.*.convergent-encryption=

#
# Specifies the hash algorithm to use for supporting key types.
# Applies to sign operations.
#
# @see <a href="https://www.vaultproject.io/api/secret/transit/index.html#hash_algorithm">api documentation for
# hash_algorithm</a>
#
#quarkus.vault.transit.key.*.hash-algorithm=

#
# Specifies the name of the key to use. By default this will be the property key alias. Used when
# the same transit key is used with different configurations. Such as in:
# ```
# quarkus.vault.transit.key.my-foo-key.name=foo
#
# quarkus.vault.transit.key.my-foo-key-with-prehashed.name=foo
# quarkus.vault.transit.key.my-foo-key-with-prehashed.prehashed=true
# ...
# transitSecretEngine.sign("my-foo-key", "my raw content");
# or
# transitSecretEngine.sign("my-foo-key-with-prehashed", "my already hashed content");
# ```
#
# @asciidoclet
#
#quarkus.vault.transit.key.*.name=

#
# Set to true when the input is already hashed.
# Applies to sign operations.
#
# @see <a href="https://www.vaultproject.io/api/secret/transit/index.html#prehashed">api documentation for prehashed</a>
#
#quarkus.vault.transit.key.*.prehashed=

#
# When using a RSA key, specifies the RSA signature algorithm.
# Applies to sign operations.
#
# @see <a href="https://www.vaultproject.io/api/secret/transit/index.html#signature_algorithm">api documentation for
# signature_algorithm</a>
#
#quarkus.vault.transit.key.*.signature-algorithm=

#
# Specifies the type of key to create for the encrypt operation.
# Applies to encrypt operations.
#
# @see <a href="https://www.vaultproject.io/api/secret/transit/index.html#type">api documentation for type</a>
#
#quarkus.vault.transit.key.*.type=

#
# Vault server url.
#
# Example: https://localhost:8200
#
# See also the documentation for the `kv-secret-engine-mount-path` property for some insights on how
# the full Vault url gets built.
#
# @asciidoclet
#
quarkus.vault.url=http://localhost:8200

#
# Enables or disables the Vert.x cache.
#
#quarkus.vertx.caching=true

#
# Enables or disabled the Vert.x classpath resource resolver.
#
#quarkus.vertx.classpath-resolving=true

#
# Enables or disables the clustering.
#
#quarkus.vertx.cluster.clustered=false

#
# The host name.
#
#quarkus.vertx.cluster.host=localhost

#
# The ping interval.
#
#quarkus.vertx.cluster.ping-interval=20

#
# The ping reply interval.
#
#quarkus.vertx.cluster.ping-reply-interval=20

#
# The port.
#
#quarkus.vertx.cluster.port=

#
# The public host name.
#
#quarkus.vertx.cluster.public-host=

#
# The public port.
#
#quarkus.vertx.cluster.public-port=

#
# The number of event loops. 2 x the number of core by default.
#
#quarkus.vertx.event-loops-pool-size=

#
# The accept backlog.
#
#quarkus.vertx.eventbus.accept-backlog=

#
# The client authentication.
#
#quarkus.vertx.eventbus.client-auth=NONE

#
# The connect timeout.
#
#quarkus.vertx.eventbus.connect-timeout=60

#
# The idle timeout in milliseconds.
#
#quarkus.vertx.eventbus.idle-timeout=

#
# Password of the key file.
#
#quarkus.vertx.eventbus.key-certificate-jks.password=

#
# Path of the key file (JKS format).
#
#quarkus.vertx.eventbus.key-certificate-jks.path=

#
# Comma-separated list of the path to the certificate files (Pem format).
#
#quarkus.vertx.eventbus.key-certificate-pem.certs=

#
# Comma-separated list of the path to the key files (Pem format).
#
#quarkus.vertx.eventbus.key-certificate-pem.keys=

#
# Password of the key.
#
#quarkus.vertx.eventbus.key-certificate-pfx.password=

#
# Path to the key file (PFX format)
#
#quarkus.vertx.eventbus.key-certificate-pfx.path=

#
# The receive buffer size.
#
#quarkus.vertx.eventbus.receive-buffer-size=

#
# The number of reconnection attempts.
#
#quarkus.vertx.eventbus.reconnect-attempts=0

#
# The reconnection interval in milliseconds.
#
#quarkus.vertx.eventbus.reconnect-interval=1

#
# Whether or not to reuse the address.
#
#quarkus.vertx.eventbus.reuse-address=true

#
# Whether or not to reuse the port.
#
#quarkus.vertx.eventbus.reuse-port=false

#
# The send buffer size.
#
#quarkus.vertx.eventbus.send-buffer-size=

#
# The so linger.
#
#quarkus.vertx.eventbus.soLinger=

#
# Enables or Disabled SSL.
#
#quarkus.vertx.eventbus.ssl=false

#
# Whether or not to keep the TCP connection opened (keep-alive).
#
#quarkus.vertx.eventbus.tcp-keep-alive=false

#
# Configure the TCP no delay.
#
#quarkus.vertx.eventbus.tcp-no-delay=true

#
# Configure the traffic class.
#
#quarkus.vertx.eventbus.traffic-class=

#
# Enables or disables the trust all parameter.
#
#quarkus.vertx.eventbus.trust-all=false

#
# Password of the key file.
#
#quarkus.vertx.eventbus.trust-certificate-jks.password=

#
# Path of the key file (JKS format).
#
#quarkus.vertx.eventbus.trust-certificate-jks.path=

#
# Comma-separated list of the trust certificate files (Pem format).
#
#quarkus.vertx.eventbus.trust-certificate-pem.certs=

#
# Password of the key.
#
#quarkus.vertx.eventbus.trust-certificate-pfx.password=

#
# Path to the key file (PFX format)
#
#quarkus.vertx.eventbus.trust-certificate-pfx.path=

#
# The size of the internal thread pool (used for the file system).
#
#quarkus.vertx.internal-blocking-pool-size=20

#
# The maximum amount of time the event loop can be blocked.
# Default is 2s.
#
#quarkus.vertx.max-event-loop-execute-time=

#
# The maximum amount of time the worker thread can be blocked.
# Default is 10s.
#
#quarkus.vertx.max-worker-execute-time=

#
# Enable or disable native transport
#
#quarkus.vertx.prefer-native-transport=false

#
# Enables the async DNS resolver.
#
#quarkus.vertx.use-async-dns=false

#
# The amount of time before a warning is displayed if the event loop is blocked.
#
#quarkus.vertx.warning-exception-time=2

#
# The size of the worker thread pool.
#
#quarkus.vertx.worker-pool-size=20

#
# y2api JT400 properties
#
com.cmfirsttech.y2.api.jt400.use-ssl=false
com.cmfirsttech.y2.api.jt400.host=${as400host}
com.cmfirsttech.y2.api.jt400.user-id=${as400user}
com.cmfirsttech.y2.api.jt400.password=${as400password}
com.cmfirsttech.y2.api.model.list-name=Y2RESTAPI
com.cmfirsttech.y2.api.model.library=CMINSMDL2
com.cmfirsttech.y2.api.model.file-for-alias=YMDLLSTRFP
com.cmfirsttech.y2.api.model.libl=QTEMP CMINSMDL2 Y2SYRPG Y2SYVENG Y2SY Y1SYDTA Y1SYVENG Y1SY QGPL

